From e16d73a6bda38e6eeced4d6fabc403acd3f0eaeb Mon Sep 17 00:00:00 2001
From: Neon <yyk1249501542@gmail.com>
Date: Tue, 19 Nov 2024 19:31:44 +0800
Subject: [PATCH 22/24] improve context button display

---
 Cargo.lock                                   |   1 +
 crates/mega/Cargo.toml                       |   1 +
 crates/mega/src/mega.rs                      | 162 ++++++++++---------
 crates/mega/src/mega_settings.rs             |   6 +-
 crates/mega/src/utils/api.rs                 |   6 +-
 crates/mega_panel/src/mega_panel.rs          |  19 ++-
 crates/mega_panel/src/mega_panel_settings.rs |   6 +-
 crates/project_panel/src/project_panel.rs    |  65 +++++---
 8 files changed, 155 insertions(+), 111 deletions(-)

diff --git a/Cargo.lock b/Cargo.lock
index a69e9c68c9..0671471f30 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -6899,6 +6899,7 @@ dependencies = [
  "bytes 1.7.2",
  "futures 0.3.30",
  "gpui",
+ "log",
  "radix_trie",
  "reqwest_client",
  "schemars",
diff --git a/crates/mega/Cargo.toml b/crates/mega/Cargo.toml
index a9a4f9d9b7..8c5596d677 100644
--- a/crates/mega/Cargo.toml
+++ b/crates/mega/Cargo.toml
@@ -23,3 +23,4 @@ bytes.workspace = true
 schemars.workspace = true
 anyhow.workspace = true
 radix_trie.workspace = true
+log.workspace = true
diff --git a/crates/mega/src/mega.rs b/crates/mega/src/mega.rs
index abc46f1651..628fe311d9 100644
--- a/crates/mega/src/mega.rs
+++ b/crates/mega/src/mega.rs
@@ -1,21 +1,23 @@
-use utils::api::{
-    ConfigRequest, ConfigResponse, MountRequest, MountResponse, MountsResponse, UmountRequest,
-    UmountResponse,
-};
 use crate::mega_settings::MegaSettings;
 use futures::channel::oneshot;
 use futures::channel::oneshot::Receiver;
 use futures::AsyncReadExt;
 use gpui::http_client::{AsyncBody, HttpClient};
-use gpui::{AppContext, EventEmitter, ModelContext};
+use gpui::{hash, AppContext, EventEmitter, ModelContext};
 use radix_trie::{Trie, TrieCommon};
 use reqwest_client::ReqwestClient;
 use settings::Settings;
+use std::collections::BTreeSet;
 use std::fmt::{Debug, Formatter};
-use std::path::PathBuf;
+use std::io::BufWriter;
+use std::path::{Path, PathBuf};
 use std::process::Command;
 use std::sync::Arc;
 use std::time::Duration;
+use utils::api::{
+    ConfigRequest, ConfigResponse, MountRequest, MountResponse, MountsResponse, UmountRequest,
+    UmountResponse,
+};
 
 mod mega_settings;
 pub mod utils;
@@ -46,7 +48,8 @@ pub struct Mega {
     heartbeat: bool,
 
     mount_point: Option<PathBuf>,
-    checkout_path: Trie<String, u64>,
+    checkout_lut: Trie<PathBuf, u64>,
+    checkout_path: BTreeSet<u64>,
 
     mega_url: String,
     fuse_url: String,
@@ -59,10 +62,13 @@ impl EventEmitter<Event> for Mega {}
 
 impl Debug for Mega {
     fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
+        let lut = self.checkout_lut.keys().map(|key| key.to_path_buf()).collect::<Vec<PathBuf>>();
+        
         write!(
             f,
-            "fuse_executable: {:?}, mega_url: {}, fuse_url: {}",
-            self.fuse_executable, self.mega_url, self.fuse_url
+            "fuse_executable: {:?}, mega_url: {}, fuse_url: {}\n\
+            LUT: {:?}",
+            self.fuse_executable, self.mega_url, self.fuse_url, lut
         )
     }
 }
@@ -85,12 +91,15 @@ impl Mega {
         // To not affected by global proxy settings.
         let client = ReqwestClient::new();
 
+        println!("Mount point: {mount_path:?}");
+
         let mount_point = if mount_path.exists() {
             Some(mount_path)
         } else {
+            log::error!("Mount point in setting does not exist");
             None
         };
-
+        
         Mega {
             fuse_executable,
 
@@ -99,6 +108,7 @@ impl Mega {
             heartbeat: false,
 
             mount_point,
+            checkout_lut: Trie::default(),
             checkout_path: Default::default(),
 
             mega_url,
@@ -108,65 +118,66 @@ impl Mega {
     }
 
     pub fn update_status(&mut self, cx: &mut ModelContext<Self>) {
-        let checkouts = self.get_checkout_paths(cx);
         let config = self.get_fuse_config(cx);
+        let checkouts = self.get_checkout_paths(cx);
 
         cx.spawn(|this, mut cx| async move {
-            if let Ok(opt) = checkouts.await {
+            // When mount point changed, emit an event.
+            // update mount point if it's none.
+            if let Ok(opt) = config.await {
                 match opt {
                     None => {
                         // This means we cannot connect to a localhost port.
                         // So we can assume that fuse has been dead.
-                        this.update(&mut cx, |mega, cx| {
+                        let _ = this.update(&mut cx, |mega, cx| {
                             mega.fuse_running = false;
                             mega.fuse_mounted = false;
                             cx.emit(Event::FuseRunning(false));
                             cx.emit(Event::FuseMounted(None));
-                        })
+                            return;
+                        });
                     }
-                    Some(info) => {
-                        // Check if checkout-ed paths are correct
-                        this.update(&mut cx, |mega, cx| {
-                            mega.fuse_running = true;
-
-                            let trie = &mut mega.checkout_path;
-                            for ref i in info.mounts {
-                                let missing = trie.get_ancestor(&i.path).is_none();
-                                if missing {
-                                    // Should not happen unless on startup.
-                                    trie.insert(i.path.clone(), i.inode);
-                                    cx.emit(Event::FuseCheckout(Some(PathBuf::from(
-                                        i.path.clone(),
-                                    ))))
+
+                    Some(config) => {
+                        let _ = this.update(&mut cx, |this, cx| {
+                            let path = PathBuf::from(config.config.mount_path);
+                            if (this.fuse_mounted && this.fuse_running) && this.mount_point.is_some() {
+                                if let Some(inner) = &this.mount_point {
+                                    if !inner.eq(&path) {
+                                        this.mount_point = Some(path);
+                                        cx.emit(Event::FuseMounted(this.mount_point.clone()));
+                                    }
+                                }
+                            } else if this.mount_point.is_none() {
+                                this.mount_point = Some(path);
+                                if this.fuse_running {
+                                    this.fuse_mounted = true;
+                                    cx.emit(Event::FuseMounted(this.mount_point.clone()));
                                 }
                             }
-                        })
+                        });
                     }
                 }
-            } else {
-                Ok(())
             }
-            .unwrap();
-
-            // When mount point changed, emit an event.
-            // update mount point if it's none.
-            if let Ok(Some(config)) = config.await {
-                this.update(&mut cx, |this, cx| {
-                    let path = PathBuf::from(config.config.mount_path);
-                    if (this.fuse_mounted && this.fuse_running) && this.mount_point.is_some() {
-                        if let Some(inner) = &this.mount_point {
-                            if !inner.eq(&path) {
-                                this.mount_point = Some(path);
-                                cx.emit(Event::FuseMounted(this.mount_point.clone()));
-                            }
+            
+            if let Ok(Some(info)) = checkouts.await {
+                // Check if checkout-ed paths are correct
+                let _ = this.update(&mut cx, |mega, cx| {
+                    mega.fuse_running = true;
+
+                    let trie = &mut mega.checkout_lut;
+                    for i in info.mounts.iter() {
+                        let path = i.path.parse().unwrap();
+
+                        let missing = trie.get_ancestor(&path).is_none();
+                        if missing {
+                            // Should not happen unless on startup.
+                            mega.checkout_path.insert(hash(&path));
+                            trie.insert(path, i.inode);
+                            cx.emit(Event::FuseCheckout(Some(PathBuf::from(i.path.clone()))));
                         }
-                    } else if this.fuse_running && this.mount_point.is_none() {
-                        this.mount_point = Some(path);
-                        cx.emit(Event::FuseMounted(this.mount_point.clone()));
                     }
-                })
-            } else {
-                Ok(())
+                });
             }
         })
         .detach();
@@ -181,7 +192,7 @@ impl Mega {
     /// Does nothing if fuse not running.
     pub fn toggle_fuse(&mut self, cx: &mut ModelContext<Self>) {
         self.update_status(cx);
-        let paths = &self.checkout_path;
+        let paths = &self.checkout_lut;
 
         if !self.fuse_running {
             return;
@@ -214,7 +225,7 @@ impl Mega {
                 let path = PathBuf::from(p); // FIXME is there a better way?
                 cx.spawn(|mega, mut cx| async move {
                     let recv = mega
-                        .update(&mut cx, |this, cx| this.restore_path(cx, path))
+                        .update(&mut cx, |this, cx| this.restore_path(cx, &path))
                         .expect("mega delegate not be dropped");
 
                     if let Ok(Some(_resp)) = recv.await {
@@ -284,18 +295,16 @@ impl Mega {
     pub fn restore_path(
         &self,
         cx: &ModelContext<Self>,
-        path: PathBuf,
+        path: &PathBuf,
     ) -> Receiver<Option<UmountResponse>> {
         let (tx, rx) = oneshot::channel();
         let client = self.http_client.clone();
         let uri = format!("{base}/api/fs/umount", base = self.fuse_url);
 
         // If panics here, that means there's a bug in code.
-        // maybe we should ensure every path absolute?
-        let path = path.to_str().unwrap();
-        let inode = self.checkout_path.get_ancestor_value(path);
+        let inode = self.checkout_lut.get_ancestor_value(path);
         let req = UmountRequest {
-            path: Some(path),
+            path: Some(path.to_str().unwrap()),
             inode: Some(inode.unwrap().to_owned()),
         };
         let body = serde_json::to_string(&req).unwrap();
@@ -427,29 +436,36 @@ impl Mega {
         .detach();
     }
 
-    pub fn is_path_checkout(&self, path: PathBuf) -> bool {
-        let set = &self.checkout_path;
+    pub fn is_path_checkout(&self, path: &PathBuf) -> bool {
+        // FIXME this function calls every time project_panel refresh * entry numbers
+        // the PathBuf construction happens right before calling this
+        // because the trie cannot receive a Arc<Path> for finding PathBuf members.
+        // LAG?
+        self.checkout_lut.get_ancestor(path).is_some()
+    }
 
-        set.get_ancestor(path.to_str().unwrap()).is_some()
+    pub fn is_path_checkout_root(&self, path: &PathBuf) -> bool {
+        self.checkout_path.contains(&hash(path))
     }
 
-    pub fn mark_checkout(&mut self, cx: &mut ModelContext<Self>, path: String, inode: u64) {
-        if self.mount_point.is_some() {
-            let path = self
-                .mount_point
-                .clone()
-                .unwrap()
-                .to_str()
-                .unwrap()
-                .to_string()
-                + path.as_str();
-            self.checkout_path.insert(path, inode);
+    pub fn mark_checkout(&mut self, cx: &mut ModelContext<Self>, path: PathBuf, inode: u64) {
+        if let Some(base) = &self.mount_point {
+            self.checkout_path.insert(hash(&path));
+            self.checkout_lut.insert(path, inode);
             cx.emit(Event::FuseCheckout(None));
         }
     }
 
-    pub fn mark_commited(&mut self, cx: &mut ModelContext<Self>, path: PathBuf) {
-        self.checkout_path.remove(path.to_str().unwrap());
+    pub fn mark_commited(&mut self, cx: &mut ModelContext<Self>, path: &PathBuf) {
+        self.checkout_path.remove(&hash(path));
+        self.checkout_lut.remove(path);
         cx.emit(Event::FuseCheckout(None));
     }
+    
+    pub fn mount_point(&self) -> Option<&PathBuf> {
+        match self.mount_point {
+            Some(ref path) => Some(path),
+            None => None
+        }
+    }
 }
diff --git a/crates/mega/src/mega_settings.rs b/crates/mega/src/mega_settings.rs
index bada5ccd80..38916f01fb 100644
--- a/crates/mega/src/mega_settings.rs
+++ b/crates/mega/src/mega_settings.rs
@@ -1,7 +1,7 @@
-use std::path::PathBuf;
-use schemars::JsonSchema;
 use gpui::private::serde_derive::{Deserialize, Serialize};
+use schemars::JsonSchema;
 use settings::{Settings, SettingsSources};
+use std::path::PathBuf;
 
 #[derive(Default, Deserialize, Debug, Clone, PartialEq)]
 pub struct MegaSettings {
@@ -47,4 +47,4 @@ impl Settings for MegaSettings {
     ) -> anyhow::Result<Self> {
         sources.json_merge()
     }
-}
\ No newline at end of file
+}
diff --git a/crates/mega/src/utils/api.rs b/crates/mega/src/utils/api.rs
index 3251888e60..f96be81187 100644
--- a/crates/mega/src/utils/api.rs
+++ b/crates/mega/src/utils/api.rs
@@ -1,7 +1,7 @@
 use serde::{Deserialize, Serialize};
 
-const SUCCESS: &str   = "Success";
-const FAIL : &str   = "Fail";
+const SUCCESS: &str = "Success";
+const FAIL: &str = "Fail";
 #[derive(Debug, Deserialize, Serialize)]
 pub struct MountRequest<'a> {
     pub path: &'a str,
@@ -102,4 +102,4 @@ impl FuseResponse for ConfigResponse {
     fn is_resp_failed(&self) -> bool {
         self.status.eq(FAIL)
     }
-}
\ No newline at end of file
+}
diff --git a/crates/mega_panel/src/mega_panel.rs b/crates/mega_panel/src/mega_panel.rs
index c5105988e0..c31a341b84 100644
--- a/crates/mega_panel/src/mega_panel.rs
+++ b/crates/mega_panel/src/mega_panel.rs
@@ -7,8 +7,8 @@ use gpui::private::serde_json;
 use gpui::{
     actions, div, Action, AppContext, AssetSource, AsyncWindowContext, Div, ElementId,
     EventEmitter, FocusHandle, FocusableView, FontWeight, InteractiveElement, IntoElement, Model,
-    ParentElement, Pixels, PromptLevel, Render, SharedString, Stateful, Styled, Task
-    , View, ViewContext, VisualContext, WeakView, WindowContext,
+    ParentElement, Pixels, PromptLevel, Render, SharedString, Stateful, Styled, Task, View,
+    ViewContext, VisualContext, WeakView, WindowContext,
 };
 use mega::Mega;
 use settings::Settings;
@@ -273,14 +273,25 @@ impl MegaPanel {
         }
 
         v_flex().id("mega-control-pad").size_full().children([
+            encap_btn(
+                Button::new("refresh_mega_status", "Refresh Status")
+                    .full_width()
+                    .icon(IconName::Control)
+                    .icon_position(IconPosition::Start)
+                    .on_click(cx.listener(|this, _, cx | {
+                        this.mega_handle.update(cx, |mega, cx| { 
+                            mega.update_status(cx);
+                            println!("{mega:?}");
+                        })
+                    }))
+            ),
             encap_btn(
                 Button::new("btn_toggle_mount", "Toggle Fuse Running")
                     .full_width()
                     .icon(IconName::Context)
                     .icon_position(IconPosition::Start)
                     .on_click(cx.listener(|this, _, cx| {
-                        this.mega_handle
-                            .update(cx, |mega, cx| mega.toggle_mount(cx));
+                        this.mega_handle.update(cx, |mega, cx| mega.toggle_mount(cx));
                     })),
             ),
             encap_btn(
diff --git a/crates/mega_panel/src/mega_panel_settings.rs b/crates/mega_panel/src/mega_panel_settings.rs
index bfd4b337d0..60c8229f77 100644
--- a/crates/mega_panel/src/mega_panel_settings.rs
+++ b/crates/mega_panel/src/mega_panel_settings.rs
@@ -1,6 +1,6 @@
-use schemars::JsonSchema;
-use gpui::Pixels;
 use gpui::private::serde::{Deserialize, Serialize};
+use gpui::Pixels;
+use schemars::JsonSchema;
 use settings::{Settings, SettingsSources};
 
 #[derive(Clone, Debug, Serialize, Deserialize, JsonSchema, Copy, PartialEq)]
@@ -44,4 +44,4 @@ impl Settings for MegaPanelSettings {
     ) -> anyhow::Result<Self> {
         sources.json_merge()
     }
-}
\ No newline at end of file
+}
diff --git a/crates/project_panel/src/project_panel.rs b/crates/project_panel/src/project_panel.rs
index 70ad294cd9..fcf0e733b1 100644
--- a/crates/project_panel/src/project_panel.rs
+++ b/crates/project_panel/src/project_panel.rs
@@ -26,7 +26,8 @@ use gpui::{
     WindowContext,
 };
 use indexmap::IndexMap;
-use mega::{api::FuseResponse, Mega};
+use mega::utils::api::FuseResponse;
+use mega::Mega;
 use menu::{Confirm, SelectFirst, SelectLast, SelectNext, SelectPrev};
 use project::{
     relativize_path, Entry, EntryKind, Fs, Project, ProjectEntryId, ProjectPath, Worktree,
@@ -44,6 +45,7 @@ use std::{
     sync::Arc,
     time::Duration,
 };
+use std::ops::Deref;
 use theme::ThemeSettings;
 use ui::{prelude::*, v_flex, ContextMenu, Icon, Label, ListItem, Tooltip};
 use util::{maybe, ResultExt, TryFutureExt};
@@ -114,6 +116,8 @@ struct EntryDetails {
     path: Arc<Path>,
     depth: usize,
     kind: EntryKind,
+    is_checkout: bool,
+    is_checkout_root: bool,
     is_ignored: bool,
     is_expanded: bool,
     is_selected: bool,
@@ -530,8 +534,8 @@ impl ProjectPanel {
             entry_id,
         });
 
-        // FIXME add fuse dir specific behaviors
         if let Some((worktree, entry)) = self.selected_sub_entry(cx) {
+            let pb: PathBuf = entry.path.to_path_buf();
             let auto_fold_dirs = ProjectPanelSettings::get_global(cx).auto_fold_dirs;
             let is_root = Some(entry) == worktree.root_entry();
             let is_dir = entry.is_dir();
@@ -541,7 +545,8 @@ impl ProjectPanel {
             let is_read_only = project.is_read_only(cx);
             let is_remote = project.is_via_collab() && project.dev_server_project_id().is_none();
             let is_local = project.is_local();
-            let is_checkout = mega.is_path_checkout(entry.path.to_path_buf());
+            let is_checkout = mega.is_path_checkout(&pb);
+            let is_checkout_root = mega.is_path_checkout_root(&pb);
 
             let context_menu = ContextMenu::build(cx, |menu, cx| {
                 menu.context(self.focus_handle.clone()).map(|menu| {
@@ -553,9 +558,11 @@ impl ProjectPanel {
                         menu.when(!is_checkout && !is_root, |menu| {
                             menu.action("Checkout Path", Box::new(CheckoutPath))
                         })
-                        .when(is_checkout, |menu| {
+                        .when(is_checkout && is_checkout_root, |menu| {
                             menu.action("Commit Path", Box::new(CommitPath))
-                                .separator()
+                        })
+                        .when(is_checkout && !is_checkout_root, |menu| {
+                            menu.separator()
                                 .action("New File", Box::new(NewFile))
                                 .action("New Folder", Box::new(NewDirectory))
                                 .separator()
@@ -604,20 +611,19 @@ impl ProjectPanel {
                             // .action("Rename", Box::new(Rename))
                         })
                         .when(!is_remote & is_root, |menu| {
-                            menu
-                                .action(
-                                    "Add Folder to Project…",
-                                    Box::new(workspace::AddFolderToProject),
-                                )
-                                .entry(
-                                    "Remove from Project",
-                                    None,
-                                    cx.handler_for(&this, move |this, cx| {
-                                        this.project.update(cx, |project, cx| {
-                                            project.remove_worktree(worktree_id, cx)
-                                        });
-                                    }),
-                                )
+                            menu.action(
+                                "Add Folder to Project…",
+                                Box::new(workspace::AddFolderToProject),
+                            )
+                            .entry(
+                                "Remove from Project",
+                                None,
+                                cx.handler_for(&this, move |this, cx| {
+                                    this.project.update(cx, |project, cx| {
+                                        project.remove_worktree(worktree_id, cx)
+                                    });
+                                }),
+                            )
                         })
                         .when(is_root, |menu| {
                             menu.separator()
@@ -1344,16 +1350,18 @@ impl ProjectPanel {
 
     fn checkout_specific_path(&mut self, _: &CheckoutPath, cx: &mut ViewContext<Self>) {
         if let Some((_, entry)) = self.selected_entry_handle(cx) {
-            let path = entry.path.clone();
+            let path = entry.path.to_path_buf();
             self.mega.update(cx, |mega, cx| {
-                let recv = mega.checkout_path(cx, path.to_path_buf());
+                println!("Checkout: {:?}", path);
+                let recv = mega.checkout_path(cx, path);
                 cx.spawn(|this, mut cx| async move {
                     let resp = recv.await;
                     println!("Response: {resp:?}");
                     if let Ok(Some(resp)) = resp {
                         if resp.is_resp_succeed() {
                             this.update(&mut cx, |mega, cx| {
-                                mega.mark_checkout(cx, resp.mount.path, resp.mount.inode);
+                                let path = resp.mount.path.parse().unwrap();
+                                mega.mark_checkout(cx, path, resp.mount.inode);
                             })
                             .expect("Mega delegate not been dropped");
                         }
@@ -1365,17 +1373,18 @@ impl ProjectPanel {
     }
 
     fn commit_specific_path(&mut self, _: &CommitPath, cx: &mut ViewContext<Self>) {
+        // TODO close windows that are in the commited paths.
         if let Some((_, entry)) = self.selected_entry_handle(cx) {
-            let path = entry.path.clone();
+            let path = entry.path.to_path_buf();
             self.mega.update(cx, |mega, cx| {
-                let recv = mega.restore_path(cx, path.to_path_buf());
+                let recv = mega.restore_path(cx, &path);
                 cx.spawn(|this, mut cx| async move {
                     let resp = recv.await;
                     println!("Response: {resp:?}");
                     if let Ok(Some(resp)) = resp {
                         if resp.is_resp_succeed() {
                             this.update(&mut cx, |mega, cx| {
-                                mega.mark_commited(cx, path.to_path_buf());
+                                mega.mark_commited(cx, &path);
                             })
                             .expect("Mega delegate not been dropped");
                         }
@@ -2302,12 +2311,18 @@ impl ProjectPanel {
                         worktree_id: snapshot.id(),
                         entry_id: entry.id,
                     };
+                    
+                    let pb = entry.path.to_path_buf();
+                    let is_checkout = self.mega.read(cx).is_path_checkout(&pb);
+                    let is_checkout_root = self.mega.read(cx).is_path_checkout_root(&pb);
                     let mut details = EntryDetails {
                         filename,
                         icon,
                         path: entry.path.clone(),
                         depth,
                         kind: entry.kind,
+                        is_checkout,
+                        is_checkout_root,
                         is_ignored: entry.is_ignored,
                         is_expanded,
                         is_selected: self.selection == Some(selection),
-- 
2.43.0

