2d1
< //  2024 From [fuse_backend_rs](https://github.com/cloud-hypervisor/fuse-backend-rs) 
7a7
> pub mod sync_io;
9,10d8
< mod async_io;
< mod layer;
12,13d9
< 
< mod tempfile;
16,36c12,31
< use std::ffi::OsStr;
< use std::future::Future;
< use std::io::{Error, ErrorKind, Result};
< 
< use std::sync::{Arc, Weak};
< use config::Config;
< use fuse3::raw::reply::{DirectoryEntry, DirectoryEntryPlus, ReplyAttr, ReplyEntry, ReplyOpen, ReplyStatFs};
< use fuse3::raw::{Filesystem, Request};
< 
< 
< use fuse3::{mode_from_kind_and_perm, Errno, FileType};
< use fuse_backend_rs::api::{SLASH_ASCII, VFS_MAX_INO};
< use futures::future::join_all;
< use futures::stream::iter;
< use futures::StreamExt;
< use inode_store::InodeStore;
< use layer::Layer;
< 
< use tokio::sync::{Mutex, RwLock};
< use crate::passthrough::PassthroughFs;
< use crate::util::atomic::*;
---
> use std::ffi::{CStr, CString};
> use std::fs::File;
> use std::io::{Error, ErrorKind, Result, Seek, SeekFrom};
> use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
> use std::sync::{Arc, Mutex, RwLock, Weak};
> 
> use crate::abi::fuse_abi::{stat64, statvfs64, CreateIn, ROOT_ID as FUSE_ROOT_ID};
> use crate::api::filesystem::{
>     Context, DirEntry, Entry, Layer, OpenOptions, ZeroCopyReader, ZeroCopyWriter,
> };
> #[cfg(not(feature = "async-io"))]
> use crate::api::BackendFileSystem;
> use crate::api::{SLASH_ASCII, VFS_MAX_INO};
> 
> use crate::common::file_buf::FileVolatileSlice;
> use crate::common::file_traits::FileReadWriteVolatile;
> use vmm_sys_util::tempfile::TempFile;
> 
> use self::config::Config;
> use self::inode_store::InodeStore;
39a35,38
> pub const MAXNAMELEN: usize = 256;
> pub const CURRENT_DIR: &str = ".";
> pub const PARENT_DIR: &str = "..";
> pub const MAXBUFSIZE: usize = 1 << 20;
41d39
< type BoxedLayer = PassthroughFs;
43c41,42
< const INODE_ALLOC_BATCH:u64 = 0x1_0000_0000;
---
> pub type BoxedLayer = Box<dyn Layer<Inode = Inode, Handle = Handle> + Send + Sync>;
> 
47d45
< #[derive(Clone)]
49c47
<     pub layer: Arc<PassthroughFs>,
---
>     pub layer: Arc<BoxedLayer>,
56c54
<     pub stat: Option<ReplyAttr>,
---
>     pub stat: Option<stat64>,
79d76
< #[allow(unused)]
88,89c85,86
<     lower_layers: Vec<Arc<PassthroughFs>>,
<     upper_layer: Option<Arc<PassthroughFs>>,
---
>     lower_layers: Vec<Arc<BoxedLayer>>,
>     upper_layer: Option<Arc<BoxedLayer>>,
100d96
<     root_inodes: u64,
104c100
<     layer: Arc<PassthroughFs>,
---
>     layer: Arc<BoxedLayer>,
121,122c117,118
<     async fn new(
<         layer: Arc<PassthroughFs>,
---
>     fn new(
>         layer: Arc<BoxedLayer>,
136c132
<         match ri.stat64_ignore_enoent(&Request::default()).await {
---
>         match ri.stat64_ignore_enoent(&Context::default()) {
147c143
<     async fn stat64(&self, req: &Request) -> Result<ReplyAttr> {
---
>     fn stat64(&self, ctx: &Context) -> Result<stat64> {
152c148,152
<         layer.getattr(*req, self.inode, None, 0).await.map_err(|e| e.into())
---
> 
>         match layer.getattr(ctx, self.inode, None) {
>             Ok((v1, _v2)) => Ok(v1),
>             Err(e) => Err(e),
>         }
155,156c155,156
<     async fn stat64_ignore_enoent(&self, req: &Request) -> Result<Option<ReplyAttr>> {
<         match self.stat64(req).await {
---
>     fn stat64_ignore_enoent(&self, ctx: &Context) -> Result<Option<stat64>> {
>         match self.stat64(ctx) {
171,172c171,172
<     async fn lookup_child_ignore_enoent(&self, ctx: Request, name: &str) -> Result<Option<ReplyEntry>> {
<         let cname = OsStr::new(name);
---
>     fn lookup_child_ignore_enoent(&self, ctx: &Context, name: &str) -> Result<Option<Entry>> {
>         let cname = CString::new(name).map_err(|e| Error::new(ErrorKind::InvalidData, e))?;
175c175
<         match layer.lookup(ctx, self.inode, cname).await {
---
>         match layer.lookup(ctx, self.inode, cname.as_c_str()) {
178c178
<                 if v.attr.ino == 0 {
---
>                 if v.inode == 0 {
184c184,190
<                 Err(e.into())
---
>                 if let Some(raw_error) = e.raw_os_error() {
>                     if raw_error == libc::ENOENT || raw_error == libc::ENAMETOOLONG {
>                         return Ok(None);
>                     }
>                 }
> 
>                 Err(e)
191c197
<     async fn lookup_child(&self, ctx: Request, name: &str) -> Result<Option<RealInode>> {
---
>     fn lookup_child(&self, ctx: &Context, name: &str) -> Result<Option<RealInode>> {
199c205
<         match self.lookup_child_ignore_enoent(ctx, name).await? {
---
>         match self.lookup_child_ignore_enoent(ctx, name)? {
202,203c208,209
<                 let (whiteout, opaque) = if v.attr.kind==FileType::Directory  {
<                     (false, layer.is_opaque(ctx, v.attr.ino).await?)
---
>                 let (whiteout, opaque) = if utils::is_dir(v.attr) {
>                     (false, layer.is_opaque(ctx, v.inode)?)
205c211
<                     (layer.is_whiteout(ctx, v.attr.ino).await?, false)
---
>                     (layer.is_whiteout(ctx, v.inode)?, false)
211c217
<                     inode: v.attr.ino,
---
>                     inode: v.inode,
214c220
<                     stat: Some(ReplyAttr { ttl: v.ttl, attr: v.attr }),
---
>                     stat: Some(v.attr),
222c228
<     async fn readdir(&self, ctx: Request) -> Result<HashMap<String, RealInode>> {
---
>     fn readdir(&self, ctx: &Context) -> Result<HashMap<String, RealInode>> {
228c234
<         let stat = match self.stat.clone() {
---
>         let stat = match self.stat {
230c236
<             None => self.stat64(&ctx).await?,
---
>             None => self.stat64(ctx)?,
234c240
<         if stat.attr.kind!=FileType::Directory {
---
>         if !utils::is_dir(stat) {
239c245
<         let opendir_res = self.layer.opendir(ctx, self.inode, libc::O_RDONLY as u32).await;
---
>         let opendir_res = self.layer.opendir(ctx, self.inode, libc::O_RDONLY as u32);
241,242c247,250
<             Ok(handle) => handle,
<    
---
>             Ok((handle, _)) => match handle {
>                 Some(h) => h,
>                 _ => 0,
>             },
245c253,265
<                 return Err(e.into());
---
>                 match e.raw_os_error() {
>                     Some(raw_error) => {
>                         if raw_error == libc::ENOSYS {
>                             // We can still call readdir with inode if opendir is not supported in this layer.
>                             0
>                         } else {
>                             return Err(e);
>                         }
>                     }
>                     None => {
>                         return Err(e);
>                     }
>                 }
249c269,275
<         let child_names =self.layer.readdir(
---
>         let mut child_names = vec![];
>         let mut more = true;
>         let mut offset = 0;
>         let bufsize = 1024;
>         while more {
>             more = false;
>             self.layer.readdir(
252,259c278,296
<                 handle.fh,
<                 0,
<             ).await?;
<         // Non-zero handle indicates successful 'open', we should 'release' it.
<         if handle.fh > 0 {
<             self.layer
<             .releasedir(ctx, self.inode, handle.fh, handle.flags).await?
<             
---
>                 handle,
>                 bufsize,
>                 offset,
>                 &mut |d| -> Result<usize> {
>                     more = true;
>                     offset = d.offset;
>                     let child_name = String::from_utf8_lossy(d.name).into_owned();
> 
>                     trace!("entry: {}", child_name.as_str());
> 
>                     if child_name.eq(CURRENT_DIR) || child_name.eq(PARENT_DIR) {
>                         return Ok(1);
>                     }
> 
>                     child_names.push(child_name);
> 
>                     Ok(1)
>                 },
>             )?;
262,271c299,309
<         // Lookup all child and construct "RealInode"s.
<         let child_real_inodes = Arc::new(Mutex::new(HashMap::new()));
<        
<         let a_map = child_names.entries.map(|entery|
<             async {
<                 match entery{
<                     Ok(dire) => {
<                         let dname = dire.name.into_string().unwrap();
<                         if let Some(child) = self.lookup_child(ctx, &dname).await.unwrap() {
<                             child_real_inodes.lock().await.insert(dname, child);
---
>         // Non-zero handle indicates successful 'open', we should 'release' it.
>         if handle > 0 {
>             if let Err(e) = self
>                 .layer
>                 .releasedir(ctx, self.inode, libc::O_RDONLY as u32, handle)
>             {
>                 // ignore ENOSYS
>                 match e.raw_os_error() {
>                     Some(raw_error) => {
>                         if raw_error != libc::ENOSYS {
>                             return Err(e);
273,275c311,314
<                         Ok(())
<                     },
<                     Err(err) => Err(err),
---
>                     }
>                     None => {
>                         return Err(e);
>                     }
278,284c317,325
<         );
<         let k = join_all(a_map.collect::<Vec<_>>().await).await ;
<         drop(k);
<          // 现在可以安全地调用 into_inner
<         let re = Arc::try_unwrap(child_real_inodes)
<         .map_err(|_|Errno::new_not_exist())? 
<         .into_inner() ;
---
>         }
> 
>         // Lookup all child and construct "RealInode"s.
>         let mut child_real_inodes = HashMap::new();
>         for name in child_names {
>             if let Some(child) = self.lookup_child(ctx, name.as_str())? {
>                 child_real_inodes.insert(name, child);
>             }
>         }
286c327
<         Ok(re)
---
>         Ok(child_real_inodes)
289c330
<     async fn create_whiteout(&self, ctx: Request, name: &str) -> Result<RealInode> {
---
>     fn create_whiteout(&self, ctx: &Context, name: &str) -> Result<RealInode> {
294,298c335,338
<             // 将 &str 转换为 &OsStr
<         let name_osstr = OsStr::new(name);
<             let entry = self
<                 .layer
<                 .create_whiteout(ctx, self.inode, name_osstr).await?;
---
>         let cname = utils::to_cstring(name)?;
>         let entry = self
>             .layer
>             .create_whiteout(ctx, self.inode, cname.as_c_str())?;
304c344
<             inode: entry.attr.ino,
---
>             inode: entry.inode,
307c347
<             stat: Some(ReplyAttr { ttl: entry.ttl, attr: entry.attr }),
---
>             stat: Some(entry.attr),
311c351
<     async fn mkdir(&self, ctx: Request, name: &str, mode: u32, umask: u32) -> Result<RealInode> {
---
>     fn mkdir(&self, ctx: &Context, name: &str, mode: u32, umask: u32) -> Result<RealInode> {
316c356
<         let name_osstr = OsStr::new(name);
---
>         let cname = utils::to_cstring(name)?;
319c359
<             .mkdir(ctx, self.inode, name_osstr, mode, umask).await?;
---
>             .mkdir(ctx, self.inode, cname.as_c_str(), mode, umask)?;
325c365
<             inode: entry.attr.ino,
---
>             inode: entry.inode,
328c368
<             stat: Some(ReplyAttr { ttl: entry.ttl, attr: entry.attr }),
---
>             stat: Some(entry.attr),
332c372
<     async fn create(
---
>     fn create(
334c374
<         ctx: Request,
---
>         ctx: &Context,
336,337c376
<         mode: u32,
<         flags: u32,
---
>         args: CreateIn,
342,343c381,382
<         let name = OsStr::new(name);
<         let create_rep =
---
> 
>         let (entry, h, _, _) =
345c384
<                 .create(ctx, self.inode, name, mode,flags).await?;
---
>                 .create(ctx, self.inode, utils::to_cstring(name)?.as_c_str(), args)?;
351c390
<                 inode: create_rep.attr.ino,
---
>                 inode: entry.inode,
354c393
<                 stat: Some(ReplyAttr { ttl:create_rep.ttl, attr: create_rep.attr }),
---
>                 stat: Some(entry.attr),
356c395
<             Some(create_rep.fh),
---
>             h,
360c399
<     async fn mknod(
---
>     fn mknod(
362,363c401,402
<         ctx: Request,
<         name: &str, 
---
>         ctx: &Context,
>         name: &str,
366c405
<         _umask: u32,
---
>         umask: u32,
371,372c410,411
<         let name = OsStr::new(name);
<         let rep = self.layer.mknod(
---
> 
>         let entry = self.layer.mknod(
375c414
<             name,
---
>             utils::to_cstring(name)?.as_c_str(),
378c417,418
<         ).await?;
---
>             umask,
>         )?;
382c422
<             inode: rep.attr.ino,
---
>             inode: entry.inode,
385,386c425,426
<             stat: Some(ReplyAttr { ttl:rep.ttl, attr: rep.attr }),
<         },)
---
>             stat: Some(entry.attr),
>         })
389c429
<     async fn link(&self, ctx: Request, ino: u64, name: &str) -> Result<RealInode> {
---
>     fn link(&self, ctx: &Context, ino: u64, name: &str) -> Result<RealInode> {
393c433
<         let name = OsStr::new(name);
---
> 
396c436
<             .link(ctx, ino, self.inode, name).await?;
---
>             .link(ctx, ino, self.inode, utils::to_cstring(name)?.as_c_str())?;
398,399c438,439
<         let opaque = if utils::is_dir(&entry.attr.kind) {
<             self.layer.is_opaque(ctx, entry.attr.ino).await?
---
>         let opaque = if utils::is_dir(entry.attr) {
>             self.layer.is_opaque(ctx, entry.inode)?
406c446
<             inode: entry.attr.ino,
---
>             inode: entry.inode,
409c449
<             stat: Some(ReplyAttr { ttl: entry.ttl, attr: entry.attr }),
---
>             stat: Some(entry.attr),
414c454
<     async fn symlink(&self, ctx: Request, link_name: &str, filename: &str) -> Result<RealInode> {
---
>     fn symlink(&self, ctx: &Context, link_name: &str, filename: &str) -> Result<RealInode> {
418,419c458
<         let link_name = OsStr::new(link_name);
<         let filename = OsStr::new(filename);
---
> 
421a461
>             utils::to_cstring(link_name)?.as_c_str(),
423,425c463,464
<             filename,
<             link_name,
<         ).await?;
---
>             utils::to_cstring(filename)?.as_c_str(),
>         )?;
429,430c468,469
<             in_upper_layer: true,
<             inode: entry.attr.ino,
---
>             in_upper_layer: self.in_upper_layer,
>             inode: entry.inode,
432,433c471,472
<             opaque:false,
<             stat: Some(ReplyAttr { ttl: entry.ttl, attr: entry.attr }),
---
>             opaque: false,
>             stat: Some(entry.attr),
438,440c477,478
< #[allow(unused)]
< impl RealInode {
<     async fn drop(&mut self) {
---
> impl Drop for RealInode {
>     fn drop(&mut self) {
442c480
<         let ctx = Request::default();
---
>         let ctx = Context::default();
446c484
<         layer.forget(ctx, inode, 1).await;
---
>         layer.forget(&ctx, inode, 1);
453a492
> 
456c495
<     pub async fn new_from_real_inode(name: &str, ino: u64, path: String, real_inode: RealInode) -> Self {
---
>     pub fn new_from_real_inode(name: &str, ino: u64, path: String, real_inode: RealInode) -> Self {
459c498
<         new.path = path;
---
>         new.path = path.clone();
461c500
<         new.whiteout.store(real_inode.whiteout).await;
---
>         new.whiteout.store(real_inode.whiteout, Ordering::Relaxed);
467c506
<     pub async fn new_from_real_inodes(
---
>     pub fn new_from_real_inodes(
483,485c522,524
<             let stat = match &ri.stat {
<                 Some(v) => v.clone(),
<                 None => ri.stat64(&Request::default()).await?,
---
>             let stat = match ri.stat {
>                 Some(v) => v,
>                 None => ri.stat64(&Context::default())?,
490c529
<                 new = Self::new_from_real_inode(name, ino, path.clone(), ri).await;
---
>                 new = Self::new_from_real_inode(name, ino, path.clone(), ri);
498c537
<                 if !utils::is_dir(&stat.attr.kind) {
---
>                 if !utils::is_dir(stat) {
514c553
<                 if !utils::is_dir(&stat.attr.kind) {
---
>                 if !utils::is_dir(stat) {
520c559
<                 new.real_inodes.lock().await.push(ri);
---
>                 new.real_inodes.lock().unwrap().push(ri);
530c569
<     pub async fn stat64(&self, ctx: Request) -> Result<ReplyAttr> {
---
>     pub fn stat64(&self, ctx: &Context) -> Result<stat64> {
532,533c571,572
<         for l in self.real_inodes.lock().await.iter() {
<             if let Some(v) = l.stat64_ignore_enoent(&ctx).await? {
---
>         for l in self.real_inodes.lock().unwrap().iter() {
>             if let Some(v) = l.stat64_ignore_enoent(ctx)? {
542c581
<     pub async fn count_entries_and_whiteout(&self, ctx: Request) -> Result<(u64, u64)> {
---
>     pub fn count_entries_and_whiteout(&self, ctx: &Context) -> Result<(u64, u64)> {
546c585
<         let st = self.stat64(ctx).await?;
---
>         let st = self.stat64(ctx)?;
549c588
<         if !utils::is_dir(&st.attr.kind) {
---
>         if !utils::is_dir(st) {
553,554c592,593
<         for (_, child) in self.childrens.lock().await.iter() {
<             if child.whiteout.load().await{
---
>         for (_, child) in self.childrens.lock().unwrap().iter() {
>             if child.whiteout.load(Ordering::Relaxed) {
564c603
<     pub async fn open(
---
>     pub fn open(
566c605
<         ctx: Request,
---
>         ctx: &Context,
568,572c607,611
<         _fuse_flags: u32,
<     ) -> Result<(Arc<BoxedLayer>, ReplyOpen)> {
<         let (layer, _, inode) = self.first_layer_inode().await;
<         let ro = layer.as_ref().open(ctx, inode, flags).await?;
<         Ok((layer, ro))
---
>         fuse_flags: u32,
>     ) -> Result<(Arc<BoxedLayer>, Option<Handle>, OpenOptions)> {
>         let (layer, _, inode) = self.first_layer_inode();
>         let (h, o, _) = layer.as_ref().open(ctx, inode, flags, fuse_flags)?;
>         Ok((layer, h, o))
576,578c615,617
<     pub async fn scan_childrens(self: &Arc<Self>, ctx: Request) -> Result<Vec<OverlayInode>> {
<         let st = self.stat64(ctx).await?;
<         if !utils::is_dir(&st.attr.kind) {
---
>     pub fn scan_childrens(self: &Arc<Self>, ctx: &Context) -> Result<Vec<OverlayInode>> {
>         let st = self.stat64(ctx)?;
>         if !utils::is_dir(st) {
585c624
<         let layers_count = self.real_inodes.lock().await.len();
---
>         let layers_count = self.real_inodes.lock().unwrap().len();
587c626
<         for ri in self.real_inodes.lock().await.iter() {
---
>         for ri in self.real_inodes.lock().unwrap().iter() {
602,604c641,643
<             let stat = match &ri.stat {
<                 Some(v) => v.clone(),
<                 None => ri.stat64(&ctx).await?,
---
>             let stat = match ri.stat {
>                 Some(v) => v,
>                 None => ri.stat64(ctx)?,
607c646
<             if !utils::is_dir(&stat.attr.kind) {
---
>             if !utils::is_dir(stat) {
614c653
<             let entries = ri.readdir(ctx).await?;
---
>             let entries = ri.readdir(ctx)?;
641c680
<             let new = Self::new_from_real_inodes(name.as_str(), 0, path, real_inodes).await?;
---
>             let new = Self::new_from_real_inodes(name.as_str(), 0, path, real_inodes)?;
649c688
<     pub async fn create_upper_dir(
---
>     pub fn create_upper_dir(
651c690
<         ctx: Request,
---
>         ctx: &Context,
654,655c693,694
<         let st = self.stat64(ctx).await?;
<         if !utils::is_dir(&st.attr.kind) {
---
>         let st = self.stat64(ctx)?;
>         if !utils::is_dir(st) {
660c699
<         if self.in_upper_layer().await {
---
>         if self.in_upper_layer() {
665c704
<         let pnode = if let Some(n) = self.parent.lock().await.upgrade() {
---
>         let pnode = if let Some(n) = self.parent.lock().unwrap().upgrade() {
671,672c710,711
<         if !pnode.in_upper_layer().await {
<             Box::pin(pnode.create_upper_dir(ctx, None)).await?; // recursive call
---
>         if !pnode.in_upper_layer() {
>             pnode.create_upper_dir(ctx, None)?; // recursive call
674,675c713,714
<         let child: Arc<Mutex<Option<RealInode>>> = Arc::new(Mutex::new(None));
<         let _ =pnode.handle_upper_inode_locked(&mut |parent_upper_inode: Option<RealInode>| async {
---
>         let mut child = None;
>         pnode.handle_upper_inode_locked(&mut |parent_upper_inode| -> Result<bool> {
680c719
<                             parent_ri.mkdir(ctx, self.name.as_str(), mode, umask).await?
---
>                             parent_ri.mkdir(ctx, self.name.as_str(), mode, umask)?
682c721
<                         None => parent_ri.mkdir(ctx, self.name.as_str(), mode_from_kind_and_perm(st.attr.kind, st.attr.perm), 0).await?,
---
>                         None => parent_ri.mkdir(ctx, self.name.as_str(), st.st_mode, 0)?,
685c724
<                     child.lock().await.replace(ri);
---
>                     child.replace(ri);
696c735
<         }).await?;
---
>         })?;
698c737
<         if let Some(ri) = child.lock().await.take() {
---
>         if let Some(ri) = child {
700c739
<             self.add_upper_inode(ri, false).await;
---
>             self.add_upper_inode(ri, false);
707,708c746,747
<     async fn add_upper_inode(self: &Arc<Self>, ri: RealInode, clear_lowers: bool) {
<         let mut inodes = self.real_inodes.lock().await;
---
>     fn add_upper_inode(self: &Arc<Self>, ri: RealInode, clear_lowers: bool) {
>         let mut inodes = self.real_inodes.lock().unwrap();
710c749
<         self.whiteout.store(ri.whiteout).await;
---
>         self.whiteout.store(ri.whiteout, Ordering::Relaxed);
723,724c762,763
<     pub async fn in_upper_layer(&self) -> bool {
<         let all_inodes = self.real_inodes.lock().await;
---
>     pub fn in_upper_layer(&self) -> bool {
>         let all_inodes = self.real_inodes.lock().unwrap();
732,733c771,772
<     pub async fn upper_layer_only(&self) -> bool {
<         let real_inodes = self.real_inodes.lock().await;
---
>     pub fn upper_layer_only(&self) -> bool {
>         let real_inodes = self.real_inodes.lock().unwrap();
747,748c786,787
<     pub async fn first_layer_inode(&self) -> (Arc<BoxedLayer>, bool, u64) {
<         let all_inodes = self.real_inodes.lock().await;
---
>     pub fn first_layer_inode(&self) -> (Arc<BoxedLayer>, bool, u64) {
>         let all_inodes = self.real_inodes.lock().unwrap();
756,757c795,796
<     pub async fn child(&self, name: &str) -> Option<Arc<OverlayInode>> {
<         self.childrens.lock().await.get(name).cloned()
---
>     pub fn child(&self, name: &str) -> Option<Arc<OverlayInode>> {
>         self.childrens.lock().unwrap().get(name).cloned()
760,761c799,800
<     pub async fn remove_child(&self, name: &str) {
<         self.childrens.lock().await.remove(name);
---
>     pub fn remove_child(&self, name: &str) {
>         self.childrens.lock().unwrap().remove(name);
764c803
<     pub async fn insert_child(&self, name: &str, node: Arc<OverlayInode>) {
---
>     pub fn insert_child(&self, name: &str, node: Arc<OverlayInode>) {
767c806
<             .await
---
>             .unwrap()
771c810
<     pub async fn handle_upper_inode_locked<F, Fut>(
---
>     pub fn handle_upper_inode_locked(
773,778c812,814
<         mut f: F,
<     ) -> Result<bool> 
<     where
<         F: FnMut(Option<RealInode>) -> Fut,
<         Fut: Future<Output = Result<bool>>, {
<         let all_inodes = self.real_inodes.lock().await;
---
>         f: &mut dyn FnMut(Option<&RealInode>) -> Result<bool>,
>     ) -> Result<bool> {
>         let all_inodes = self.real_inodes.lock().unwrap();
783c819
<                     f(Some(v.clone())).await
---
>                     f(Some(v))
785c821
<                     f(None).await
---
>                     f(None)
798c834
< #[allow(unused)]
---
> 
811c847
< #[allow(unused)]
---
> 
817d852
<         root_inode:u64,
832d866
<             root_inodes: root_inode,
837c871
<         self.root_inodes
---
>         FUSE_ROOT_ID
840,841c874,875
<     async fn alloc_inode(&self, path: &str) -> Result<u64> {
<         self.inodes.write().await.alloc_inode(path)
---
>     fn alloc_inode(&self, path: &String) -> Result<u64> {
>         self.inodes.write().unwrap().alloc_inode(path)
844c878
<     pub async fn import(&self) -> Result<()> {
---
>     pub fn import(&self) -> Result<()> {
846c880
<         root.inode = self.root_inode();
---
>         root.inode = FUSE_ROOT_ID;
851c885
<         let ctx = Request::default();
---
>         let ctx = Context::default();
856,862c890,891
<             let real = RealInode::new(
<                 layer.clone(), 
<                 true, ino, 
<                 false, 
<                 layer.is_opaque(ctx, ino).await?
<             ).await;
<             root.real_inodes.lock().await.push(real);
---
>             let real = RealInode::new(layer.clone(), true, ino, false, layer.is_opaque(&ctx, ino)?);
>             root.real_inodes.lock().unwrap().push(real);
868c897
<             let real: RealInode = RealInode::new(
---
>             let real = RealInode::new(
873,875c902,904
<                 layer.is_opaque(ctx, ino).await?,
<             ).await;
<             root.real_inodes.lock().await.push(real);
---
>                 layer.is_opaque(&ctx, ino)?,
>             );
>             root.real_inodes.lock().unwrap().push(real);
880c909
<         self.insert_inode(self.root_inode(), Arc::clone(&root_node)).await;
---
>         self.insert_inode(FUSE_ROOT_ID, Arc::clone(&root_node));
883c912
<         self.load_directory(ctx, &root_node).await?;
---
>         self.load_directory(&ctx, &root_node)?;
888c917
<     async fn root_node(&self) -> Arc<OverlayInode> {
---
>     fn root_node(&self) -> Arc<OverlayInode> {
890c919
<         self.get_active_inode(self.root_inode()).await.unwrap()
---
>         self.get_active_inode(FUSE_ROOT_ID).unwrap()
893,894c922,923
<     async fn insert_inode(&self, inode: u64, node: Arc<OverlayInode>) {
<         self.inodes.write().await.insert_inode(inode, node);
---
>     fn insert_inode(&self, inode: u64, node: Arc<OverlayInode>) {
>         self.inodes.write().unwrap().insert_inode(inode, node);
897,898c926,927
<     async fn get_active_inode(&self, inode: u64) -> Option<Arc<OverlayInode>> {
<         self.inodes.read().await.get_inode(inode)
---
>     fn get_active_inode(&self, inode: u64) -> Option<Arc<OverlayInode>> {
>         self.inodes.read().unwrap().get_inode(inode)
902,903c931,932
<     async fn get_all_inode(&self, inode: u64) -> Option<Arc<OverlayInode>> {
<         let inode_store = self.inodes.read().await;
---
>     fn get_all_inode(&self, inode: u64) -> Option<Arc<OverlayInode>> {
>         let inode_store = self.inodes.read().unwrap();
911c940
<     async fn remove_inode(&self, inode: u64, path_removed: Option<String>) -> Option<Arc<OverlayInode>> {
---
>     fn remove_inode(&self, inode: u64, path_removed: Option<String>) -> Option<Arc<OverlayInode>> {
914,915c943,944
<             .await
<             .remove_inode(inode, path_removed).await
---
>             .unwrap()
>             .remove_inode(inode, path_removed)
921c950
<     async fn lookup_node(&self, ctx: Request, parent: Inode, name: &str) -> Result<Arc<OverlayInode>> {
---
>     fn lookup_node(&self, ctx: &Context, parent: Inode, name: &str) -> Result<Arc<OverlayInode>> {
927c956
<         let pnode = match self.get_active_inode(parent).await {
---
>         let pnode = match self.get_active_inode(parent) {
933c962
<         if pnode.whiteout.load().await {
---
>         if pnode.whiteout.load(Ordering::Relaxed) {
937,938c966,967
<         let st = pnode.stat64(ctx).await?;
<         if utils::is_dir(&st.attr.kind) && !pnode.loaded.load().await {
---
>         let st = pnode.stat64(ctx)?;
>         if utils::is_dir(st) && !pnode.loaded.load(Ordering::Relaxed) {
940c969
<             self.load_directory(ctx, &pnode).await?;
---
>             self.load_directory(ctx, &pnode)?;
946c975
<             || (parent == self.root_inode() && name.eq("..")) 
---
>             || (parent == FUSE_ROOT_ID && name.eq("..")) 
953c982
<         match pnode.child(name).await {
---
>         match pnode.child(name) {
962,963c991,992
<     async fn debug_print_all_inodes(&self) {
<         self.inodes.read().await.debug_print_all_inodes();
---
>     fn debug_print_all_inodes(&self) {
>         self.inodes.read().unwrap().debug_print_all_inodes();
966c995
<     async fn lookup_node_ignore_enoent(
---
>     fn lookup_node_ignore_enoent(
968c997
<         ctx: Request,
---
>         ctx: &Context,
972c1001
<         match self.lookup_node(ctx, parent, name).await {
---
>         match self.lookup_node(ctx, parent, name) {
986,987c1015,1016
<     async fn load_directory(&self, ctx: Request, node: &Arc<OverlayInode>) -> Result<()> {
<         if node.loaded.load().await {
---
>     fn load_directory(&self, ctx: &Context, node: &Arc<OverlayInode>) -> Result<()> {
>         if node.loaded.load(Ordering::Relaxed) {
992c1021
<         let childrens = node.scan_childrens(ctx).await?;
---
>         let childrens = node.scan_childrens(ctx)?;
996c1025
<         let mut inode_store = self.inodes.write().await;
---
>         let mut inode_store = self.inodes.write().unwrap();
998c1027
<         let mut node_children = node.childrens.lock().await;
---
>         let mut node_children = node.childrens.lock().unwrap();
1001c1030
<         if node.loaded.load().await {
---
>         if node.loaded.load(Ordering::Relaxed) {
1021c1050
<         node.loaded.store(true).await;
---
>         node.loaded.store(true, Ordering::Relaxed);
1026c1055
<     async fn forget_one(&self, inode: Inode, count: u64) {
---
>     fn forget_one(&self, inode: Inode, count: u64) {
1031c1060
<         let v = match self.get_all_inode(inode).await {
---
>         let v = match self.get_all_inode(inode) {
1040c1069
<         let mut lookups = v.lookups.load().await;
---
>         let mut lookups = v.lookups.load(Ordering::Relaxed);
1047c1076
<         v.lookups.store(lookups).await;
---
>         v.lookups.store(lookups, Ordering::Relaxed);
1054,1055c1083,1084
<             let _ = self.remove_inode(inode, None).await;
<             let parent = v.parent.lock().await;
---
>             let _ = self.remove_inode(inode, None);
>             let parent = v.parent.lock().unwrap();
1059c1088
<                 p.remove_child(v.name.as_str()).await;
---
>                 p.remove_child(v.name.as_str());
1064,1065c1093,1094
<     async fn do_lookup(&self, ctx: Request, parent: Inode, name: &str) -> Result<ReplyEntry> {
<         let node = self.lookup_node(ctx, parent, name).await?;
---
>     fn do_lookup(&self, ctx: &Context, parent: Inode, name: &str) -> Result<Entry> {
>         let node = self.lookup_node(ctx, parent, name)?;
1067c1096
<         if node.whiteout.load().await {
---
>         if node.whiteout.load(Ordering::Relaxed) {
1071,1074c1100,1103
<         let mut st = node.stat64(ctx).await?;
<         st.attr.ino = node.inode;
<         if utils::is_dir(&st.attr.kind) && !node.loaded.load().await {
<             self.load_directory(ctx, &node).await?;
---
>         let st = node.stat64(ctx)?;
> 
>         if utils::is_dir(st) && !node.loaded.load(Ordering::Relaxed) {
>             self.load_directory(ctx, &node)?;
1078c1107
<         let tmp = node.lookups.fetch_add(1).await;
---
>         let tmp = node.lookups.fetch_add(1, Ordering::Relaxed);
1080,1082c1109,1110
<         Ok(ReplyEntry{
<             ttl: st.ttl,
<             attr: st.attr,
---
>         Ok(Entry {
>             inode: node.inode,
1083a1112,1115
>             attr: st,
>             attr_flags: 0,
>             attr_timeout: self.config.attr_timeout,
>             entry_timeout: self.config.entry_timeout,
1085,1092d1116
<         // Ok(Entry {
<         //     inode: node.inode,
<         //     generation: 0,
<         //     attr: st,
<         //     attr_flags: 0,
<         //     attr_timeout: self.config.attr_timeout,
<         //     entry_timeout: self.config.entry_timeout,
<         // })
1095,1096c1119,1120
<     async fn do_statvfs(&self, ctx: Request, inode: Inode) -> Result<ReplyStatFs> {
<         match self.get_active_inode(inode).await {
---
>     fn do_statvfs(&self, ctx: &Context, inode: Inode) -> Result<statvfs64> {
>         match self.get_active_inode(inode) {
1098c1122
<                 let all_inodes = ovi.real_inodes.lock().await;
---
>                 let all_inodes = ovi.real_inodes.lock().unwrap();
1102c1126
<                 Ok(real_inode.layer.statfs(ctx, real_inode.inode).await?)
---
>                 real_inode.layer.statfs(ctx, real_inode.inode)
1109c1133
<     async fn do_readdir<'a>(
---
>     fn do_readdir(
1111c1135
<         ctx: Request,
---
>         ctx: &Context,
1113a1138
>         size: u32,
1116,1117c1141,1151
<     ) -> Result<<OverlayFs as fuse3::raw::Filesystem>::DirEntryStream<'a>> {
< 
---
>         add_entry: &mut dyn FnMut(DirEntry, Option<Entry>) -> Result<usize>,
>     ) -> Result<()> {
>         trace!(
>             "do_readir: handle: {}, size: {}, offset: {}",
>             handle,
>             size,
>             offset
>         );
>         if size == 0 {
>             return Ok(());
>         }
1120c1154
<         let ovl_inode = match self.handles.lock().await.get(&handle) {
---
>         let ovl_inode = match self.handles.lock().unwrap().get(&handle) {
1124c1158
<                 let node = self.lookup_node(ctx, inode, ".").await?;
---
>                 let node = self.lookup_node(ctx, inode, ".")?;
1126,1127c1160,1161
<                 let st = node.stat64(ctx).await?;
<                 if !utils::is_dir(&st.attr.kind) {
---
>                 let st = node.stat64(ctx)?;
>                 if !utils::is_dir(st) {
1140c1174
<         let parent_node = match ovl_inode.parent.lock().await.upgrade() {
---
>         let parent_node = match ovl_inode.parent.lock().unwrap().upgrade() {
1142c1176
<             None => self.root_node().await,
---
>             None => self.root_node(),
1146c1180
<         for (_, child) in ovl_inode.childrens.lock().await.iter() {
---
>         for (_, child) in ovl_inode.childrens.lock().unwrap().iter() {
1148c1182
<             if child.whiteout.load().await {
---
>             if child.whiteout.load(Ordering::Relaxed) {
1156c1190
<             return Ok(iter(vec![].into_iter()));
---
>             return Ok(());
1158d1191
<         let mut d:Vec<std::result::Result<DirectoryEntry, Errno>> = Vec::new();
1163,1168c1196,1201
<                 let st = child.stat64(ctx).await?;
<                 let dir_entry = DirectoryEntry {
<                     inode: child.inode,
<                     kind: st.attr.kind,
<                     name: name.into(),
<                     offset: (index + 1) as i64,
---
>                 let st = child.stat64(ctx)?;
>                 let dir_entry = DirEntry {
>                     ino: st.st_ino,
>                     offset: index + 1,
>                     type_: entry_type_from_mode(st.st_mode) as u32,
>                     name: name.as_bytes(),
1170,1195d1202
<                 // let pentry = DirectoryEntryPlus{
<                 //     inode,
<                 //     generation: 0,
<                 //     kind: st.attr.kind,
<                 //     name: name.into(),
<                 //     offset: (index + 1) as i64,
<                 //     attr: st.attr,
<                 //     entry_ttl: todo!(),
<                 //     attr_ttl: todo!(),
<                 // }
<                 d.push(Ok(dir_entry));
<             }
<         }
< 
<         Ok(iter(d.into_iter()))
<     }
< 
<     #[allow(clippy::too_many_arguments)]
<     async fn do_readdirplus<'a>(
<         &self,
<         ctx: Request,
<         inode: Inode,
<         handle: u64,
<         offset: u64,
<         is_readdirplus: bool,
<     ) -> Result<<OverlayFs as fuse3::raw::Filesystem>::DirEntryPlusStream<'a>> {
1196a1204,1225
>                 let entry = if is_readdirplus {
>                     child.lookups.fetch_add(1, Ordering::Relaxed);
>                     Some(Entry {
>                         inode: child.inode,
>                         generation: 0,
>                         attr: st,
>                         attr_flags: 0,
>                         attr_timeout: self.config.attr_timeout,
>                         entry_timeout: self.config.entry_timeout,
>                     })
>                 } else {
>                     None
>                 };
>                 match add_entry(dir_entry, entry) {
>                     Ok(0) => break,
>                     Ok(l) => {
>                         len += l;
>                         if len as u32 >= size {
>                             // no more space, stop here
>                             return Ok(());
>                         }
>                     }
1198,1207c1227,1234
<         // lookup the directory
<         let ovl_inode = match self.handles.lock().await.get(&handle) {
<             Some(dir) => dir.node.clone(),
<             None => {
<                 // Try to get data with inode.
<                 let node = self.lookup_node(ctx, inode, ".").await?;
< 
<                 let st = node.stat64(ctx).await?;
<                 if !utils::is_dir(&st.attr.kind) {
<                     return Err(Error::from_raw_os_error(libc::ENOTDIR));
---
>                     Err(e) => {
>                         // when the buffer is still empty, return error, otherwise return the entry already added
>                         if len == 0 {
>                             return Err(e);
>                         } else {
>                             return Ok(());
>                         }
>                     }
1209,1228d1235
< 
<                 node.clone()
<             }
<         };
< 
<         let mut childrens = Vec::new();
<         //add myself as "."
<         childrens.push((".".to_string(), ovl_inode.clone()));
< 
<         //add parent
<         let parent_node = match ovl_inode.parent.lock().await.upgrade() {
<             Some(p) => p.clone(),
<             None => self.root_node().await,
<         };
<         childrens.push(("..".to_string(), parent_node));
< 
<         for (_, child) in ovl_inode.childrens.lock().await.iter() {
<             // skip whiteout node
<             if child.whiteout.load().await {
<                 continue;
1230d1236
<             childrens.push((child.name.clone(), child.clone()));
1233,1270c1239
<         let mut len: usize = 0;
<         if offset >= childrens.len() as u64 {
<             return Ok(iter(vec![].into_iter()));
<         }
<         let mut d:Vec<std::result::Result<DirectoryEntryPlus, Errno>> = Vec::new();
< 
<         for (index, (name, child)) in (0_u64..).zip(childrens.into_iter()) {
<             if index >= offset {
<                 // make struct DireEntry and Entry
<                 let mut st = child.stat64(ctx).await?;
<                 child.lookups.fetch_add(1).await;
<                 st.attr.ino = child.inode;
<                 println!("--entry name:{}",name);
<                 let dir_entry = DirectoryEntryPlus { 
<                     inode:child.inode, 
<                     generation: 0, 
<                     kind: st.attr.kind, 
<                     name: name.into(), 
<                     offset: (index + 1) as i64, 
<                     attr: st.attr, 
<                     entry_ttl: st.ttl, 
<                     attr_ttl:st.ttl
<                 };
<                 // let pentry = DirectoryEntryPlus{
<                 //     inode,
<                 //     generation: 0,
<                 //     kind: st.attr.kind,
<                 //     name: name.into(),
<                 //     offset: (index + 1) as i64,
<                 //     attr: st.attr,
<                 //     entry_ttl: todo!(),
<                 //     attr_ttl: todo!(),
<                 // }
<                 d.push(Ok(dir_entry));
<             }
<         }
< 
<         Ok(iter(d.into_iter()))
---
>         Ok(())
1272c1241,1242
<     async fn do_mkdir(
---
> 
>     fn do_mkdir(
1274c1244
<         ctx: Request,
---
>         ctx: &Context,
1285c1255
<         if parent_node.whiteout.load().await {
---
>         if parent_node.whiteout.load(Ordering::Relaxed) {
1291c1261
<         if let Some(n) = self.lookup_node_ignore_enoent(ctx, parent_node.inode, name).await? {
---
>         if let Some(n) = self.lookup_node_ignore_enoent(ctx, parent_node.inode, name)? {
1293c1263
<             if !n.whiteout.load().await {
---
>             if !n.whiteout.load(Ordering::Relaxed) {
1297c1267
<             if n.in_upper_layer().await {
---
>             if n.in_upper_layer() {
1302c1272
<             if !n.upper_layer_only().await {
---
>             if !n.upper_layer_only() {
1308c1278
<         let pnode = self.copy_node_up(ctx, Arc::clone(parent_node)).await?;
---
>         let pnode = self.copy_node_up(ctx, Arc::clone(parent_node))?;
1310c1280
<        
---
>         let mut new_node = None;
1312,1314c1282
<         let path_ref = &path;  
<         let new_node = Arc::new(Mutex::new(None));
<         pnode.handle_upper_inode_locked( &mut |parent_real_inode: Option<RealInode>| async {
---
>         pnode.handle_upper_inode_locked(&mut |parent_real_inode| -> Result<bool> {
1322c1290
<             let osstr = OsStr::new(name);
---
> 
1327,1328c1295,1296
<                     osstr,
<                 ).await;
---
>                     utils::to_cstring(name)?.as_c_str(),
>                 );
1330d1297
<             
1332,1333c1299,1300
<             let ino = self.alloc_inode(path_ref).await?;
<             let child_dir = parent_real_inode.mkdir(ctx, name, mode, umask).await?;
---
>             let ino = self.alloc_inode(&path)?;
>             let child_dir = parent_real_inode.mkdir(ctx, name, mode, umask)?;
1336c1303
<                 parent_real_inode.layer.set_opaque(ctx, child_dir.inode).await?;
---
>                 parent_real_inode.layer.set_opaque(ctx, child_dir.inode)?;
1338,1341c1305
<             let ovi = OverlayInode::new_from_real_inode(name, ino, path_ref.clone(), child_dir).await;
<             new_node.lock().await.replace(ovi);
<             Ok(false)
<         }).await?;
---
>             let ovi = OverlayInode::new_from_real_inode(name, ino, path.clone(), child_dir);
1342a1307,1309
>             new_node.replace(ovi);
>             Ok(false)
>         })?;
1345,1348c1312,1314
<         let nn = new_node.lock().await.take();
<         let arc_node = Arc::new(nn.unwrap());
<         self.insert_inode(arc_node.inode, arc_node.clone()).await;
<         pnode.insert_child(name, arc_node).await;
---
>         let arc_node = Arc::new(new_node.unwrap());
>         self.insert_inode(arc_node.inode, arc_node.clone());
>         pnode.insert_child(name, arc_node);
1352c1318
<     async fn do_mknod(
---
>     fn do_mknod(
1354c1320
<         ctx: Request,
---
>         ctx: &Context,
1366c1332
<         if parent_node.whiteout.load().await {
---
>         if parent_node.whiteout.load(Ordering::Relaxed) {
1370c1336
<         match self.lookup_node_ignore_enoent(ctx, parent_node.inode, name).await? {
---
>         match self.lookup_node_ignore_enoent(ctx, parent_node.inode, name)? {
1373c1339
<                 if !n.whiteout.load().await {
---
>                 if !n.whiteout.load(Ordering::Relaxed) {
1378,1379c1344,1345
<                 let pnode = self.copy_node_up(ctx, Arc::clone(parent_node)).await?;
<                 pnode.handle_upper_inode_locked(&mut |parent_real_inode: Option<RealInode>|  async {
---
>                 let pnode = self.copy_node_up(ctx, Arc::clone(parent_node))?;
>                 pnode.handle_upper_inode_locked(&mut |parent_real_inode| -> Result<bool> {
1387,1388c1353,1354
<                     let osstr = OsStr::new(name);
<                     if n.in_upper_layer().await {
---
> 
>                     if n.in_upper_layer() {
1392,1393c1358,1359
<                             osstr,
<                         ).await;
---
>                             utils::to_cstring(name)?.as_c_str(),
>                         );
1396c1362
<                     let child_ri = parent_real_inode.mknod(ctx, name, mode, rdev, umask).await?;
---
>                     let child_ri = parent_real_inode.mknod(ctx, name, mode, rdev, umask)?;
1399c1365
<                     n.add_upper_inode(child_ri, true).await;
---
>                     n.add_upper_inode(child_ri, true);
1401c1367
<                 }).await?;
---
>                 })?;
1405,1406c1371,1372
<                 let pnode = self.copy_node_up(ctx, Arc::clone(parent_node)).await?;
<                 let mut new_node =  Arc::new(Mutex::new(None));
---
>                 let pnode = self.copy_node_up(ctx, Arc::clone(parent_node))?;
>                 let mut new_node = None;
1408c1374
<                 pnode.handle_upper_inode_locked(&mut |parent_real_inode: Option<RealInode>| async  {
---
>                 pnode.handle_upper_inode_locked(&mut |parent_real_inode| -> Result<bool> {
1418,1420c1384,1386
<                     let ino = self.alloc_inode(&path).await?;
<                     let child_ri = parent_real_inode.mknod(ctx, name, mode, rdev, umask).await?;
<                     let ovi = OverlayInode::new_from_real_inode(name, ino, path.clone(), child_ri).await;
---
>                     let ino = self.alloc_inode(&path)?;
>                     let child_ri = parent_real_inode.mknod(ctx, name, mode, rdev, umask)?;
>                     let ovi = OverlayInode::new_from_real_inode(name, ino, path.clone(), child_ri);
1422c1388
<                     new_node.lock().await.replace(ovi);
---
>                     new_node.replace(ovi);
1424c1390
<                 }).await?;
---
>                 })?;
1426,1429c1392,1395
<                 let nn = new_node.lock().await.take();
<                 let arc_node = Arc::new(nn.unwrap());
<                 self.insert_inode(arc_node.inode, arc_node.clone()).await;
<                 pnode.insert_child(name, arc_node).await;
---
>                 // new_node is always 'Some'
>                 let arc_node = Arc::new(new_node.unwrap());
>                 self.insert_inode(arc_node.inode, arc_node.clone());
>                 pnode.insert_child(name, arc_node);
1436c1402
<     async fn do_create(
---
>     fn do_create(
1438c1404
<         ctx: Request,
---
>         ctx: &Context,
1440,1442c1406,1407
<         name: &OsStr,
<         mode: u32,
<         flags: u32,
---
>         name: &str,
>         args: CreateIn,
1444d1408
<         let name_str = name.to_str().unwrap();
1452c1416
<         if parent_node.whiteout.load().await {
---
>         if parent_node.whiteout.load(Ordering::Relaxed) {
1456,1458c1420,1422
<         let mut handle: Arc<Mutex<Option<u64>>> = Arc::new(Mutex::new(None));
<         let mut real_ino : Arc<Mutex<Option<u64>>> = Arc::new(Mutex::new(None));;
<         let new_ovi = match self.lookup_node_ignore_enoent(ctx, parent_node.inode, name_str).await? {
---
>         let mut handle = None;
>         let mut real_ino = 0u64;
>         let new_ovi = match self.lookup_node_ignore_enoent(ctx, parent_node.inode, name)? {
1461c1425
<                 if !n.whiteout.load().await {
---
>                 if !n.whiteout.load(Ordering::Relaxed) {
1466,1467c1430,1431
<                 let pnode = self.copy_node_up(ctx, Arc::clone(parent_node)).await?;
<                 pnode.handle_upper_inode_locked(&mut |parent_real_inode:Option<RealInode>| async {
---
>                 let pnode = self.copy_node_up(ctx, Arc::clone(parent_node))?;
>                 pnode.handle_upper_inode_locked(&mut |parent_real_inode| -> Result<bool> {
1476c1440
<                     if n.in_upper_layer().await {
---
>                     if n.in_upper_layer() {
1480,1481c1444,1445
<                             name,
<                         ).await;
---
>                             utils::to_cstring(name)?.as_c_str(),
>                         );
1484,1486c1448,1450
<                     let (child_ri, hd) = parent_real_inode.create(ctx, name_str, mode,flags).await?;
<                     real_ino.lock().await.replace(child_ri.inode);
<                     handle.lock().await.replace(hd.unwrap());
---
>                     let (child_ri, hd) = parent_real_inode.create(ctx, name, args)?;
>                     real_ino = child_ri.inode;
>                     handle = hd;
1489c1453
<                     n.add_upper_inode(child_ri, true).await;
---
>                     n.add_upper_inode(child_ri, true);
1491c1455
<                 }).await?;
---
>                 })?;
1496,1499c1460,1463
<                 let pnode = self.copy_node_up(ctx, Arc::clone(parent_node)).await?;
<                 let mut new_node = Arc::new(Mutex::new(None));
<                 let path = format!("{}/{}", pnode.path, name_str);
<                 pnode.handle_upper_inode_locked(&mut |parent_real_inode:Option<RealInode>| async {
---
>                 let pnode = self.copy_node_up(ctx, Arc::clone(parent_node))?;
>                 let mut new_node = None;
>                 let path = format!("{}/{}", pnode.path, name);
>                 pnode.handle_upper_inode_locked(&mut |parent_real_inode| -> Result<bool> {
1508,1510c1472,1474
<                     let (child_ri, hd) = parent_real_inode.create(ctx, name_str, mode,flags).await?;
<                     real_ino.lock().await.replace(child_ri.inode);
<                     handle.lock().await.replace(hd.unwrap());
---
>                     let (child_ri, hd) = parent_real_inode.create(ctx, name, args)?;
>                     real_ino = child_ri.inode;
>                     handle = hd;
1512,1513c1476,1477
<                     let ino = self.alloc_inode(&path).await?;
<                     let ovi = OverlayInode::new_from_real_inode(name_str, ino, path.clone(), child_ri).await;
---
>                     let ino = self.alloc_inode(&path)?;
>                     let ovi = OverlayInode::new_from_real_inode(name, ino, path.clone(), child_ri);
1515c1479
<                     new_node.lock().await.replace(ovi);
---
>                     new_node.replace(ovi);
1517c1481
<                 }).await?;
---
>                 })?;
1520,1523c1484,1486
<                 let nn = new_node.lock().await.take();
<                 let arc_node = Arc::new(nn.unwrap());
<                 self.insert_inode(arc_node.inode, arc_node.clone()).await;
<                 pnode.insert_child(name_str, arc_node.clone()).await;
---
>                 let arc_node = Arc::new(new_node.unwrap());
>                 self.insert_inode(arc_node.inode, arc_node.clone());
>                 pnode.insert_child(name, arc_node.clone());
1528c1491
<         let final_handle = match *handle.lock().await {
---
>         let final_handle = match handle {
1530c1493
<                 if self.no_open.load().await {
---
>                 if self.no_open.load(Ordering::Relaxed) {
1533c1496
<                     let handle = self.next_handle.fetch_add(1).await;
---
>                     let handle = self.next_handle.fetch_add(1, Ordering::Relaxed);
1539c1502
<                             inode: real_ino.lock().await.unwrap(),
---
>                             inode: real_ino,
1545c1508
<                         .await
---
>                         .unwrap()
1555c1518
<     async fn do_link(
---
>     fn do_link(
1557c1520
<         ctx: Request,
---
>         ctx: &Context,
1562d1524
<         let name_os = OsStr::new(name);
1568c1530
<         if src_node.whiteout.load().await || new_parent.whiteout.load().await
---
>         if src_node.whiteout.load(Ordering::Relaxed) || new_parent.whiteout.load(Ordering::Relaxed)
1573,1574c1535,1536
<         let st = src_node.stat64(ctx).await?;
<         if utils::is_dir(&st.attr.kind) {
---
>         let st = src_node.stat64(ctx)?;
>         if utils::is_dir(st) {
1579,1581c1541,1543
<         let src_node = self.copy_node_up(ctx, Arc::clone(src_node)).await?;
<         let new_parent = self.copy_node_up(ctx, Arc::clone(new_parent)).await?;
<         let src_ino = src_node.first_layer_inode().await.2;
---
>         let src_node = self.copy_node_up(ctx, Arc::clone(src_node))?;
>         let new_parent = self.copy_node_up(ctx, Arc::clone(new_parent))?;
>         let src_ino = src_node.first_layer_inode().2;
1583c1545
<         match self.lookup_node_ignore_enoent(ctx, new_parent.inode, name).await? {
---
>         match self.lookup_node_ignore_enoent(ctx, new_parent.inode, name)? {
1586c1548
<                 if !n.whiteout.load().await {
---
>                 if !n.whiteout.load(Ordering::Relaxed) {
1591c1553
<                 new_parent.handle_upper_inode_locked(&mut |parent_real_inode:Option<RealInode> | async {
---
>                 new_parent.handle_upper_inode_locked(&mut |parent_real_inode| -> Result<bool> {
1601c1563
<                     if n.in_upper_layer().await {
---
>                     if n.in_upper_layer() {
1605,1606c1567,1568
<                             name_os,
<                         ).await;
---
>                             utils::to_cstring(name)?.as_c_str(),
>                         );
1609c1571
<                     let child_ri = parent_real_inode.link(ctx, src_ino, name).await?;
---
>                     let child_ri = parent_real_inode.link(ctx, src_ino, name)?;
1612c1574
<                     n.add_upper_inode(child_ri, true).await;
---
>                     n.add_upper_inode(child_ri, true);
1614c1576
<                 }).await?;
---
>                 })?;
1618,1619c1580,1581
<                 let mut new_node: Arc<Mutex<Option<OverlayInode>>> = Arc::new(Mutex::new(None));
<                 new_parent.handle_upper_inode_locked(&mut |parent_real_inode: Option<RealInode> | async  {
---
>                 let mut new_node = None;
>                 new_parent.handle_upper_inode_locked(&mut |parent_real_inode| -> Result<bool> {
1630,1632c1592,1594
<                     let ino = self.alloc_inode(&path).await?;
<                     let child_ri = parent_real_inode.link(ctx, src_ino, name).await?;
<                     let ovi = OverlayInode::new_from_real_inode(name, ino, path, child_ri).await;
---
>                     let ino = self.alloc_inode(&path)?;
>                     let child_ri = parent_real_inode.link(ctx, src_ino, name)?;
>                     let ovi = OverlayInode::new_from_real_inode(name, ino, path, child_ri);
1634c1596
<                     new_node.lock().await.replace(ovi);
---
>                     new_node.replace(ovi);
1636c1598
<                 }).await?;
---
>                 })?;
1639,1641c1601,1603
<                 let arc_node = Arc::new(new_node.lock().await.take().unwrap());
<                 self.insert_inode(arc_node.inode, arc_node.clone()).await;
<                 new_parent.insert_child(name, arc_node).await;
---
>                 let arc_node = Arc::new(new_node.unwrap());
>                 self.insert_inode(arc_node.inode, arc_node.clone());
>                 new_parent.insert_child(name, arc_node);
1648c1610
<     async fn do_symlink(
---
>     fn do_symlink(
1650c1612
<         ctx: Request,
---
>         ctx: &Context,
1655d1616
<         let name_os = OsStr::new(name);
1661c1622
<         if parent_node.whiteout.load().await {
---
>         if parent_node.whiteout.load(Ordering::Relaxed) {
1665c1626
<         match self.lookup_node_ignore_enoent(ctx, parent_node.inode, name).await? {
---
>         match self.lookup_node_ignore_enoent(ctx, parent_node.inode, name)? {
1668c1629
<                 if !n.whiteout.load().await {
---
>                 if !n.whiteout.load(Ordering::Relaxed) {
1673,1674c1634,1635
<                 let pnode = self.copy_node_up(ctx, Arc::clone(parent_node)).await?;
<                 pnode.handle_upper_inode_locked(&mut |parent_real_inode:Option<RealInode>| async {
---
>                 let pnode = self.copy_node_up(ctx, Arc::clone(parent_node))?;
>                 pnode.handle_upper_inode_locked(&mut |parent_real_inode| -> Result<bool> {
1683c1644
<                     if n.in_upper_layer().await {
---
>                     if n.in_upper_layer() {
1687,1688c1648,1649
<                             name_os,
<                         ).await;
---
>                             utils::to_cstring(name)?.as_c_str(),
>                         );
1691c1652
<                     let child_ri = parent_real_inode.symlink(ctx, linkname, name).await?;
---
>                     let child_ri = parent_real_inode.symlink(ctx, linkname, name)?;
1694c1655
<                     n.add_upper_inode(child_ri, true).await;
---
>                     n.add_upper_inode(child_ri, true);
1696c1657
<                 }).await?;
---
>                 })?;
1700,1701c1661,1662
<                 let pnode = self.copy_node_up(ctx, Arc::clone(parent_node)).await?;
<                 let mut new_node: Arc<Mutex<Option<OverlayInode>>> = Arc::new(Mutex::new(None));
---
>                 let pnode = self.copy_node_up(ctx, Arc::clone(parent_node))?;
>                 let mut new_node = None;
1703c1664
<                 pnode.handle_upper_inode_locked(&mut |parent_real_inode:Option<RealInode> | async  {
---
>                 pnode.handle_upper_inode_locked(&mut |parent_real_inode| -> Result<bool> {
1713,1715c1674,1676
<                     let ino = self.alloc_inode(&path).await?;
<                     let child_ri = parent_real_inode.symlink(ctx, linkname, name).await?;
<                     let ovi = OverlayInode::new_from_real_inode(name, ino, path.clone(), child_ri).await;
---
>                     let ino = self.alloc_inode(&path)?;
>                     let child_ri = parent_real_inode.symlink(ctx, linkname, name)?;
>                     let ovi = OverlayInode::new_from_real_inode(name, ino, path.clone(), child_ri);
1717c1678
<                     new_node.lock().await.replace(ovi);
---
>                     new_node.replace(ovi);
1719c1680
<                 }).await?;
---
>                 })?;
1722,1724c1683,1685
<                 let arc_node = Arc::new(new_node.lock().await.take().unwrap());
<                 self.insert_inode(arc_node.inode, arc_node.clone()).await;
<                 pnode.insert_child(name, arc_node).await;
---
>                 let arc_node = Arc::new(new_node.unwrap());
>                 self.insert_inode(arc_node.inode, arc_node.clone());
>                 pnode.insert_child(name, arc_node);
1731,1732c1692,1693
<     async fn copy_symlink_up(&self, ctx: Request, node: Arc<OverlayInode>) -> Result<Arc<OverlayInode>> {
<         if node.in_upper_layer().await {
---
>     fn copy_symlink_up(&self, ctx: &Context, node: Arc<OverlayInode>) -> Result<Arc<OverlayInode>> {
>         if node.in_upper_layer() {
1736c1697
<         let parent_node = if let Some(ref n) = node.parent.lock().await.upgrade() {
---
>         let parent_node = if let Some(ref n) = node.parent.lock().unwrap().upgrade() {
1742c1703
<         let (self_layer, _, self_inode) = node.first_layer_inode().await;
---
>         let (self_layer, _, self_inode) = node.first_layer_inode();
1744,1745c1705,1706
<         if !parent_node.in_upper_layer().await {
<             parent_node.create_upper_dir(ctx, None).await?;
---
>         if !parent_node.in_upper_layer() {
>             parent_node.create_upper_dir(ctx, None)?;
1749c1710
<         let reply_data = self_layer.readlink(ctx, self_inode).await?;
---
>         let path = self_layer.readlink(ctx, self_inode)?;
1752c1713
<             std::str::from_utf8(&reply_data.data).map_err(|_| Error::from_raw_os_error(libc::EINVAL))?;
---
>             std::str::from_utf8(&path).map_err(|_| Error::from_raw_os_error(libc::EINVAL))?;
1754,1756c1715,1716
<         
<         let mut new_upper_real: Arc<Mutex<Option<RealInode>>> = Arc::new(Mutex::new(None));
<         parent_node.handle_upper_inode_locked(&mut |parent_upper_inode:Option<RealInode>| async {
---
>         let mut new_upper_real = None;
>         parent_node.handle_upper_inode_locked(&mut |parent_upper_inode| -> Result<bool> {
1760c1720
<             new_upper_real.lock().await.replace(parent_real_inode.symlink(ctx, path, node.name.as_str()).await?);
---
>             new_upper_real.replace(parent_real_inode.symlink(ctx, path, node.name.as_str())?);
1762c1722
<         }).await?;
---
>         })?;
1764c1724
<         if let Some(real_inode) = new_upper_real.lock().await.take() {
---
>         if let Some(real_inode) = new_upper_real {
1766c1726
<             node.add_upper_inode(real_inode, true).await;
---
>             node.add_upper_inode(real_inode, true);
1774,1775c1734,1735
<     async fn copy_regfile_up(&self, ctx: Request, node: Arc<OverlayInode>) -> Result<Arc<OverlayInode>> {
<         if node.in_upper_layer().await {
---
>     fn copy_regfile_up(&self, ctx: &Context, node: Arc<OverlayInode>) -> Result<Arc<OverlayInode>> {
>         if node.in_upper_layer() {
1779c1739
<         let parent_node = if let Some(ref n) = node.parent.lock().await.upgrade() {
---
>         let parent_node = if let Some(ref n) = node.parent.lock().unwrap().upgrade() {
1785,1786c1745,1746
<         let st = node.stat64(ctx).await?;
<         let (lower_layer, _, lower_inode) = node.first_layer_inode().await;
---
>         let st = node.stat64(ctx)?;
>         let (lower_layer, _, lower_inode) = node.first_layer_inode();
1788,1789c1748,1749
<         if !parent_node.in_upper_layer().await {
<             parent_node.create_upper_dir(ctx, None).await?;
---
>         if !parent_node.in_upper_layer() {
>             parent_node.create_upper_dir(ctx, None)?;
1793,1800c1753,1762
<         
<         let  flags = libc::O_WRONLY ;
<         let mode =  mode_from_kind_and_perm(st.attr.kind,st.attr.perm) ;
<           
< 
<         let mut upper_handle = Arc::new(Mutex::new(0));
<         let mut upper_real_inode =Arc::new(Mutex::new(None));
<         parent_node.handle_upper_inode_locked(&mut |parent_upper_inode:Option<RealInode> | async {
---
>         let args = CreateIn {
>             flags: libc::O_WRONLY as u32,
>             mode: st.st_mode,
>             umask: 0,
>             fuse_flags: 0,
>         };
> 
>         let mut upper_handle = 0u64;
>         let mut upper_real_inode = None;
>         parent_node.handle_upper_inode_locked(&mut |parent_upper_inode| -> Result<bool> {
1806,1808c1768,1770
<             let (inode, h) = parent_real_inode.create(ctx, node.name.as_str(), mode,flags.try_into().unwrap()).await?;
<             *upper_handle.lock().await = h.unwrap_or(0);
<             upper_real_inode.lock().await.replace(inode);
---
>             let (inode, h) = parent_real_inode.create(ctx, node.name.as_str(), args)?;
>             upper_handle = h.unwrap_or(0);
>             upper_real_inode.replace(inode);
1810c1772
<         }).await?;
---
>         })?;
1812c1774
<         let rep = lower_layer.open(ctx, lower_inode, libc::O_RDONLY as u32).await?;
---
>         let (h, _, _) = lower_layer.open(ctx, lower_inode, libc::O_RDONLY as u32, 0)?;
1814c1776
<         let lower_handle = rep.fh;
---
>         let lower_handle = h.unwrap_or(0);
1822c1784
<         
---
>         let mut file = TempFile::new().unwrap().into_file();
1825,1835c1787,1803
<         
<         let ret = lower_layer.read(
<             ctx,
<             lower_inode,
<             lower_handle,
<             offset as u64,
<             size,
<         ).await?;
<         
<         offset += ret.data.len();
<         
---
>         loop {
>             let ret = lower_layer.read(
>                 ctx,
>                 lower_inode,
>                 lower_handle,
>                 &mut file,
>                 size,
>                 offset as u64,
>                 None,
>                 0,
>             )?;
>             if ret == 0 {
>                 break;
>             }
> 
>             offset += ret;
>         }
1837c1805
<         lower_layer.release(ctx, lower_inode, lower_handle, 0,0, true).await?;
---
>         lower_layer.release(ctx, lower_inode, 0, lower_handle, true, true, None)?;
1838a1807
>         file.seek(SeekFrom::Start(0))?;
1840,1841c1809,1810
<         let u_handle = *upper_handle.lock().await;
<         while let Some(ref ri) = upper_real_inode.lock().await.take() {
---
> 
>         while let Some(ref ri) = upper_real_inode {
1845c1814,1816
<                 *upper_handle.lock().await,
---
>                 upper_handle,
>                 &mut file,
>                 size,
1847c1818,1819
<                 &ret.data,
---
>                 None,
>                 false,
1850,1851c1822,1823
<             ).await?;
<             if ret.written == 0 {
---
>             )?;
>             if ret == 0 {
1855c1827
<             offset += ret.written as usize;
---
>             offset += ret;
1857a1830,1831
>         // Drop will remove file automatically.
>         drop(file);
1859,1860c1833
< 
<         if let Some(ri) = upper_real_inode.lock().await.take() {
---
>         if let Some(ri) = upper_real_inode {
1863,1865c1836,1837
<                 .release(ctx, ri.inode, u_handle,0,  0, true).await
<             {   
<                 let e:std::io::Error = e.into();
---
>                 .release(ctx, ri.inode, 0, upper_handle, true, true, None)
>             {
1873c1845
<             node.add_upper_inode(ri, true).await;
---
>             node.add_upper_inode(ri, true);
1879,1880c1851,1852
<     async fn copy_node_up(&self, ctx: Request, node: Arc<OverlayInode>) -> Result<Arc<OverlayInode>> {
<         if node.in_upper_layer().await {
---
>     fn copy_node_up(&self, ctx: &Context, node: Arc<OverlayInode>) -> Result<Arc<OverlayInode>> {
>         if node.in_upper_layer() {
1884c1856
<         let st = node.stat64(ctx).await?;
---
>         let st = node.stat64(ctx)?;
1886,1887c1858,1859
<         if utils::is_dir(&st.attr.kind) {
<             node.create_upper_dir(ctx, None).await?;
---
>         if utils::is_dir(st) {
>             node.create_upper_dir(ctx, None)?;
1892,1893c1864,1865
<         if st.attr.kind.const_into_mode_t() & libc::S_IFMT == libc::S_IFLNK {
<             return self.copy_symlink_up(ctx, Arc::clone(&node)).await;
---
>         if st.st_mode & libc::S_IFMT == libc::S_IFLNK {
>             return self.copy_symlink_up(ctx, Arc::clone(&node));
1897c1869
<         self.copy_regfile_up(ctx, Arc::clone(&node)).await
---
>         self.copy_regfile_up(ctx, Arc::clone(&node))
1900c1872
<     async fn do_rm(&self, ctx: Request, parent: u64, name: &OsStr, dir: bool) -> Result<()> {
---
>     fn do_rm(&self, ctx: &Context, parent: u64, name: &CStr, dir: bool) -> Result<()> {
1906,1907c1878,1879
<         let pnode = self.lookup_node(ctx, parent, "").await?;
<         if pnode.whiteout.load().await{
---
>         let pnode = self.lookup_node(ctx, parent, "")?;
>         if pnode.whiteout.load(Ordering::Relaxed) {
1910c1882
<         let to_name = name.to_str().unwrap();
---
> 
1912,1913c1884,1886
<         let node = self.lookup_node(ctx, parent, to_name).await?;
<         if node.whiteout.load().await {
---
>         let sname = name.to_string_lossy().to_string();
>         let node = self.lookup_node(ctx, parent, sname.as_str())?;
>         if node.whiteout.load(Ordering::Relaxed) {
1919,1920c1892,1893
<             self.load_directory(ctx, &node).await?;
<             let (count, whiteouts) = node.count_entries_and_whiteout(ctx).await?;
---
>             self.load_directory(ctx, &node)?;
>             let (count, whiteouts) = node.count_entries_and_whiteout(ctx)?;
1927,1928c1900,1901
<             if whiteouts > 0 && node.in_upper_layer().await {
<                 self.empty_node_directory(ctx, Arc::clone(&node)).await?;
---
>             if whiteouts > 0 && node.in_upper_layer() {
>                 self.empty_node_directory(ctx, Arc::clone(&node))?;
1934,1935c1907,1908
<         let mut need_whiteout = Arc::new(Mutex::new(true));
<         let pnode = self.copy_node_up(ctx, Arc::clone(&pnode)).await?;
---
>         let mut need_whiteout = true;
>         let pnode = self.copy_node_up(ctx, Arc::clone(&pnode))?;
1937,1938c1910,1911
<         if node.upper_layer_only().await {
<             *need_whiteout.lock().await = false;
---
>         if node.upper_layer_only() {
>             need_whiteout = false;
1942,1943c1915,1916
<         if node.in_upper_layer().await {
<             pnode.handle_upper_inode_locked(&mut |parent_upper_inode:Option<RealInode>| async {
---
>         if node.in_upper_layer() {
>             pnode.handle_upper_inode_locked(&mut |parent_upper_inode| -> Result<bool> {
1954c1927
<                     *need_whiteout.lock().await = false;
---
>                     need_whiteout = false;
1959c1932
<                         .rmdir(ctx, parent_real_inode.inode, name).await?;
---
>                         .rmdir(ctx, parent_real_inode.inode, name)?;
1963c1936
<                         .unlink(ctx, parent_real_inode.inode, name).await?;
---
>                         .unlink(ctx, parent_real_inode.inode, name)?;
1967c1940
<             }).await?;
---
>             })?;
1978c1951
<         node.lookups.fetch_sub(1).await;
---
>         node.lookups.fetch_sub(1, Ordering::Relaxed);
1981,1982c1954,1955
<         self.remove_inode(node.inode, path_removed).await;
<         pnode.remove_child(node.name.as_str()).await;
---
>         self.remove_inode(node.inode, path_removed);
>         pnode.remove_child(node.name.as_str());
1984c1957
<         if *need_whiteout.lock().await {
---
>         if need_whiteout {
1987c1960
<             pnode.handle_upper_inode_locked(&mut |parent_upper_inode: Option<RealInode>| async  {
---
>             pnode.handle_upper_inode_locked(&mut |parent_upper_inode| -> Result<bool> {
1996,1998c1969,1971
<                 let child_ri = parent_real_inode.create_whiteout(ctx, to_name).await?;
<                 let path = format!("{}/{}", pnode.path, to_name);
<                 let ino = self.alloc_inode(&path).await?;
---
>                 let child_ri = parent_real_inode.create_whiteout(ctx, sname.as_str())?;
>                 let path = format!("{}/{}", pnode.path, sname);
>                 let ino = self.alloc_inode(&path)?;
2000c1973
<                     to_name,
---
>                     sname.as_str(),
2004c1977
<                 ).await);
---
>                 ));
2006,2007c1979,1980
<                 self.insert_inode(ino, ovi.clone()).await;
<                 pnode.insert_child(to_name, ovi.clone()).await;
---
>                 self.insert_inode(ino, ovi.clone());
>                 pnode.insert_child(sname.as_str(), ovi.clone());
2009c1982
<             }).await?;
---
>             })?;
2015c1988
<     async fn do_fsync(
---
>     fn do_fsync(
2017c1990
<         ctx: Request,
---
>         ctx: &Context,
2024c1997
<         let data = self.get_data(ctx, Some(handle), inode, libc::O_RDONLY as u32).await?;
---
>         let data = self.get_data(ctx, Some(handle), inode, libc::O_RDONLY as u32)?;
2030c2003
<                 let real_handle = rh.handle.load().await;
---
>                 let real_handle = rh.handle.load(Ordering::Relaxed);
2033c2006
<                     rh.layer.fsyncdir(ctx, rh.inode, real_handle, datasync).await.map_err(|e| e.into())
---
>                     rh.layer.fsyncdir(ctx, rh.inode, datasync, real_handle)
2035c2008
<                     rh.layer.fsync(ctx, rh.inode, real_handle, datasync).await.map_err(|e| e.into())
---
>                     rh.layer.fsync(ctx, rh.inode, datasync, real_handle)
2042,2044c2015,2017
<     async fn empty_node_directory(&self, ctx: Request, node: Arc<OverlayInode>) -> Result<()> {
<         let st = node.stat64(ctx).await?;
<         if !utils::is_dir(&st.attr.kind) {
---
>     fn empty_node_directory(&self, ctx: &Context, node: Arc<OverlayInode>) -> Result<()> {
>         let st = node.stat64(ctx)?;
>         if !utils::is_dir(st) {
2049c2022
<         let (layer, in_upper, inode) = node.first_layer_inode().await;
---
>         let (layer, in_upper, inode) = node.first_layer_inode();
2059c2032
<             .await
---
>             .unwrap()
2066,2068c2039,2040
<             if child.in_upper_layer().await {
<                 if child.whiteout.load().await {
<                     let child_name_os = OsStr::new(child.name.as_str());
---
>             if child.in_upper_layer() {
>                 if child.whiteout.load(Ordering::Relaxed) {
2072,2073c2044,2045
<                         child_name_os,
<                     ).await?
---
>                         utils::to_cstring(child.name.as_str())?.as_c_str(),
>                     )?
2075,2078c2047,2050
<                     let s = child.stat64(ctx).await?;
<                     let cname: &OsStr = OsStr::new(&child.name);
<                     if utils::is_dir(&s.attr.kind) {
<                         let (count, whiteouts) = child.count_entries_and_whiteout(ctx).await?;
---
>                     let s = child.stat64(ctx)?;
>                     let cname = utils::to_cstring(&child.name)?;
>                     if utils::is_dir(s) {
>                         let (count, whiteouts) = child.count_entries_and_whiteout(ctx)?;
2080,2083c2052
<                             let cb = child.clone();
<                             Box::pin(async move {
<                                 self.empty_node_directory(ctx, cb).await
<                             }).await?;
---
>                             self.empty_node_directory(ctx, Arc::clone(&child))?;
2085c2054,2055
<                         layer.rmdir(ctx, inode, cname).await?
---
> 
>                         layer.rmdir(ctx, inode, cname.as_c_str())?
2087c2057
<                         layer.unlink(ctx, inode, cname).await?;
---
>                         layer.unlink(ctx, inode, cname.as_c_str())?;
2092,2093c2062,2063
<                 self.remove_inode(child.inode, Some(child.path.clone())).await;
<                 node.remove_child(child.name.as_str()).await;
---
>                 self.remove_inode(child.inode, Some(child.path.clone()));
>                 node.remove_child(child.name.as_str());
2100c2070
<     async fn find_real_info_from_handle(
---
>     fn find_real_info_from_handle(
2104c2074
<         match self.handles.lock().await.get(&handle) {
---
>         match self.handles.lock().unwrap().get(&handle) {
2109c2079
<                     rhd.handle.load().await,
---
>                     rhd.handle.load(Ordering::Relaxed),
2118,2120c2088,2090
<     async fn find_real_inode(&self, inode: Inode) -> Result<(Arc<BoxedLayer>, Inode)> {
<         if let Some(n) = self.get_active_inode(inode).await {
<             let (first_layer, _, first_inode) = n.first_layer_inode().await;
---
>     fn find_real_inode(&self, inode: Inode) -> Result<(Arc<BoxedLayer>, Inode)> {
>         if let Some(n) = self.get_active_inode(inode) {
>             let (first_layer, _, first_inode) = n.first_layer_inode();
2127c2097
<     async fn get_data(
---
>     fn get_data(
2129c2099
<         ctx: Request,
---
>         ctx: &Context,
2134c2104
<         let no_open = self.no_open.load().await;
---
>         let no_open = self.no_open.load(Ordering::Relaxed);
2137c2107
<                 if let Some(v) = self.handles.lock().await.get(&h) {
---
>                 if let Some(v) = self.handles.lock().unwrap().get(&h) {
2150c2120
<             let node = self.lookup_node(ctx, inode, "").await?;
---
>             let node = self.lookup_node(ctx, inode, "")?;
2153c2123
<             if node.whiteout.load().await {
---
>             if node.whiteout.load(Ordering::Relaxed) {
2164c2134
<                 self.copy_node_up(ctx, Arc::clone(&node)).await?;
---
>                 self.copy_node_up(ctx, Arc::clone(&node))?;
2167c2137
<             let (layer, in_upper_layer, inode) = node.first_layer_inode().await;
---
>             let (layer, in_upper_layer, inode) = node.first_layer_inode();
2181a2152
> }
2183,2188c2154,2174
<     
<     // extend or init the inodes number to one overlay if the current number is done.
<     pub async fn extend_inode_alloc(&self,key:u64){
<         let next_inode = key * INODE_ALLOC_BATCH;
<         let limit_inode = next_inode + INODE_ALLOC_BATCH -1;
<         self.inodes.write().await.extend_inode_number(next_inode, limit_inode);
---
> impl ZeroCopyReader for File {
>     // Copies at most count bytes from self directly into f at offset off
>     // without storing it in any intermediate buffers.
>     fn read_to(
>         &mut self,
>         f: &mut dyn FileReadWriteVolatile,
>         count: usize,
>         off: u64,
>     ) -> Result<usize> {
>         let mut buf = vec![0_u8; count];
>         let slice = unsafe { FileVolatileSlice::from_raw_ptr(buf.as_mut_ptr(), count) };
> 
>         // Read from self to slice.
>         let ret = self.read_volatile(slice)?;
>         if ret > 0 {
>             let slice = unsafe { FileVolatileSlice::from_raw_ptr(buf.as_mut_ptr(), ret) };
>             // Write from slice to f at offset off.
>             f.write_at_volatile(slice, off)
>         } else {
>             Ok(0)
>         }
2191a2178,2199
> impl ZeroCopyWriter for File {
>     // Copies at most count bytes from f at offset off directly into self
>     // without storing it in any intermediate buffers.
>     fn write_from(
>         &mut self,
>         f: &mut dyn FileReadWriteVolatile,
>         count: usize,
>         off: u64,
>     ) -> Result<usize> {
>         let mut buf = vec![0_u8; count];
>         let slice = unsafe { FileVolatileSlice::from_raw_ptr(buf.as_mut_ptr(), count) };
>         // Read from f at offset off to slice.
>         let ret = f.read_at_volatile(slice, off)?;
> 
>         if ret > 0 {
>             let slice = unsafe { FileVolatileSlice::from_raw_ptr(buf.as_mut_ptr(), ret) };
>             // Write from slice to self.
>             self.write_volatile(slice)
>         } else {
>             Ok(0)
>         }
>     }
2193,2195c2201,2204
< #[cfg(test)]
< mod tests {
<  
---
>     fn available_bytes(&self) -> usize {
>         // Max usize
>         usize::MAX
>     }
2197a2207,2215
> #[cfg(not(feature = "async-io"))]
> impl BackendFileSystem for OverlayFs {
>     /// mount returns the backend file system root inode entry and
>     /// the largest inode number it has.
>     fn mount(&self) -> Result<(Entry, u64)> {
>         let ctx = Context::default();
>         let entry = self.do_lookup(&ctx, self.root_inode(), "")?;
>         Ok((entry, VFS_MAX_INO))
>     }
2198a2217,2223
>     /// Provides a reference to the Any trait. This is useful to let
>     /// the caller have access to the underlying type behind the
>     /// trait.
>     fn as_any(&self) -> &dyn std::any::Any {
>         self
>     }
> }
